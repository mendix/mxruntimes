import{o as observable,g as comparer,d as computed,a as action,r as reaction}from"./d4030583.js";import"./43297fe2.js";import{e as ensure,m as mapValues}from"./c49f953c.js";import"./0e7164f2.js";import"./b98156b5.js";import"./ee5a929f.js";import{v as valueMonitor,b as using,i as asReloadable,f as flatMapL,u as unavailable,a as available,m as mapL,g as getOrElseL}from"./189c82c6.js";import"big.js";import{p as pageScope}from"./8676e47e.js";import{a as asProperty}from"./72a4665b.js";import{k as attributeToClientValue,w as attributeValueToExpressionVariable,x as assertIsAttributeValue}from"./d6b7d05a.js";import{H as getTypeValidation,t as translate}from"./da601b36.js";import{V as ValidationError}from"./e7efb4be.js";import"./df897ee2.js";import{M as MxObject1,A as Access,s as serverValidate$,a as accessible}from"./2745d635.js";import{e as getActionParameters$}from"./49a60b8f.js";import{b as evaluateFormExpression$}from"./7ca6d1ae.js";import"./5dae8521.js";import{e as executeAction}from"./459bd237.js";import"./09e8fbb9.js";import{c as createFormatter}from"./155debd6.js";function getValidationMessage(value,object,store,customValidator,config){const attributeType=object.getAttributeType(config.attribute);return"unparsed"===value.state?function(value,attribute,type){switch(type){case"Enum":case"Boolean":case"ObjectReference":case"ObjectReferenceSet":return translate("mendix.lib.Validations","invalid_attribute",value,attribute);case"DateTime":return translate("mendix.lib.Validations","invalid_date");case"Integer":case"Long":case"Decimal":return translate("mendix.lib.Validations","invalid_number");default:throw new Error(`Attribute type ${type} is not supported.`)}}(value.value,config.attribute,attributeType):function(value,type){return getTypeValidation(attributeToClientValue(value),type)}(value.value,attributeType)||(customValidator?customValidator(value.value):void 0)||(config.validation?function(value,type,store,validation,friendlyId){if(!evaluateFormExpression$(validation.expression,store,`Validation of ${friendlyId}`,{value:()=>attributeValueToExpressionVariable(value,type,guid=>ensure(mx.data.getCachedObject(guid)))}))return validation.message||translate("mendix.lib.Validations","required_field");return}(value.value,attributeType,store,config.validation,config.friendlyId):void 0)}const AttributeProperty=asProperty((config,store,widgetId)=>{const defaultFormatter=createFormatter(config.entity,config.attribute,config.formatting||{}),universe=function(config){const metaObject=mx.meta.getEntity(config.entity);switch(metaObject.getAttributeType(config.attribute)){case"Enum":return metaObject.getEnumMap(config.attribute).map(e=>e.key);case"Boolean":return[!0,!1];default:return}}(config),formatter=observable.box(defaultFormatter,{deep:!1}),invalidValue=observable.box(void 0,{deep:!1,equals:comparer.structural}),validation=observable.box(void 0);let customValidator;const submittedValue=computed(()=>{const path=config.path,rootObject=MxObject1.fromState$(store.get$(config.scope,"object")),object=path?flatMapL(rootObject,ro=>ro.getByPath$(path)):rootObject;return flatMapL(object,o=>{const attribute=o.get$(config.attribute);if(attribute.access===Access.None)return function(config){mx.logger.debug(`No access to attribute "${config.attribute}" of entity "${config.entity}" in widget ${config.friendlyId}.`)}(config),unavailable();const readOnlyState=Boolean(store.get$(pageScope,"subtreeReadonly"));try{const computedEditable=void 0===config.isEditable||evaluateFormExpression$(config.isEditable,store,`Editability of ${config.friendlyId}`),readOnly=attribute.access===Access.Read||readOnlyState||!computedEditable;return available({object:o,attribute:attribute.value,readOnly:readOnly})}catch(e){return function(config,e){mx.onError(new Error(`An error occurred while evaluating conditional editability expression in ${config.friendlyId}: ${e.message}`))}(config,e),unavailable()}})}),submittedValueMonitor=valueMonitor(()=>submittedValue.get()),serverValidationMonitor=valueMonitor((function(){const object=mapL(submittedValue.get(),x=>x.object),validationL=mapL(object,o=>serverValidate$(`Validation of ${config.friendlyId}`,o.getGuid(),config.attribute));return getOrElseL(validationL,void 0)})),result=using(()=>[reaction(()=>store.get$(pageScope,"validationRequest"),validateCurrentValue),reaction(()=>void 0!==validation.get(),isInvalid=>store.set(widgetId,"isInvalid",isInvalid),{fireImmediately:!0}),()=>store.set(widgetId,"isInvalid",!1),reaction(()=>getOrElseL(mapL(submittedValue.get(),v=>v.readOnly?void 0:v.object.old()),void 0),object=>store.set(widgetId,"object",void 0!==object?available(object):unavailable()),{fireImmediately:!0})],()=>{serverValidationMonitor.runIfChanged(val=>{validation.set(val?val[0]:void 0)}),submittedValueMonitor.runIfChanged(()=>{invalidValue.set(void 0),validation.set(void 0)});const submitted=submittedValue.get(),invalid=invalidValue.get(),value="available"!==submitted.status?void 0:void 0!==invalid&&"unparsed"===invalid.state?void 0:void 0!==invalid?invalid.value:submitted.value.attribute,displayValue="available"!==submitted.status?"":void 0!==invalid&&"unparsed"===invalid.state?invalid.value:formatter.get().format(void 0!==invalid?invalid.value:submitted.value.attribute);return{status:submitted.status,value:value,displayValue:displayValue,readOnly:"available"!==submitted.status||submitted.value.readOnly,validation:validation.get(),formatter:formatter.get(),universe:universe,setValidator:_customValidator=>{customValidator=_customValidator},setValue:action(newValue=>"available"!==submitted.status?noDataAvailableError(config):submitted.value.readOnly?noWriteAccessError(config):setValue({state:"parsed",value:newValue},submitted.value.object)),setTextValue:action(newValue=>"available"!==submitted.status?noDataAvailableError(config):submitted.value.readOnly?noWriteAccessError(config):setValue({state:"unparsed",value:newValue},submitted.value.object)),setFormatter:action(f=>formatter.set(f||defaultFormatter))}}),reloadable=asReloadable(()=>result.get(),v=>({value:v.value,displayValue:v.displayValue}));return()=>reloadable.get();function validateCurrentValue(){const value=submittedValue.get();if("available"!==value.status)return;const currentValue=invalidValue.get()||{state:"parsed",value:value.value.attribute};try{validation.set(getValidationMessage(currentValue,value.value.object,store,customValidator,config))}catch(e){!function(config,e){mx.onError(new Error(`An error occurred while validating current value in ${config.friendlyId}: ${e.message}`))}(config,e)}}function setValue(newValue,object){if("unparsed"===newValue.state){const parseResult=formatter.get().parse(newValue.value);newValue=parseResult.valid?{state:"parsed",value:parseResult.value}:newValue}else assertIsAttributeValue(newValue.value,config.entity,config.attribute);try{const newValidation=getValidationMessage(newValue,object,store,customValidator,config);if(void 0!==newValidation)validation.set(newValidation),invalidValue.set(newValue);else{const oldValue=object.get$(config.attribute);comparer.structural(oldValue,accessible(newValue.value))?(invalidValue.set(void 0),validation.set(void 0)):(object.set(config.attribute,newValue.value),function(){const parameters=getActionParameters$(config.onChange.argMap,store),currentForm=ensure(store.get$(pageScope,"form"))[0];setTimeout(()=>{executeAction(config.onChange,{abortOnClientValidations:!0,abortOnServerValidations:!1,widgetIsValid:!0,currentForm:currentForm},mapValues(parameters,v=>getOrElseL(v,void 0)),void 0,e=>(function(config,e){e instanceof ValidationError||mx.onError(new Error(`An error occurred while executing On change at ${config.friendlyId}: ${e.message}`))})(config,e))},0)}())}}catch(e){!function(config,e){mx.onError(new Error(`An error occurred while validating new value set by ${config.friendlyId}: ${e.message}`))}(config,e)}}});function noDataAvailableError(config){mx.logger.debug(`Widget ${config.friendlyId} is attempting to change the value of attribute "${config.attribute}" of entity "${config.entity}" which is not available.`)}function noWriteAccessError(config){mx.logger.debug(`Widget ${config.friendlyId} is attempting to change the value of attribute "${config.attribute}" of entity "${config.entity}" which is not writable.`)}export{AttributeProperty};
