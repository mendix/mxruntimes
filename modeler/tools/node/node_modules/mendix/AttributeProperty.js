import{o as observable,e as comparer,f as computed,a as action,r as reaction}from"./ef69c932.js";import{e as ensure,m as mapValues}from"./0e413733.js";import{a as asProperty}from"./e3b801f3.js";import{p as pageScope}from"./5838721f.js";import{c as getActionParameters$}from"./5f481ef5.js";import"./fdd4c4ff.js";import{l as attributeToClientValue,x as attributeToExpressionVariable,y as assertIsAttributeValue}from"./d25c5dcf.js";import{H as getTypeValidation,t as translate}from"./9df15dda.js";import"./573c00fc.js";import{v as valueMonitor,b as using,i as asReloadable,m as mapL,g as getOrElseL,f as flatMapL,u as unavailable,a as available,e as getOrCrashL}from"./b3d27a00.js";import{M as MxObject1,A as Access,s as serverValidate$,a as accessible}from"./0b8ac900.js";import"./b92dd682.js";import{E as Evaluator,e as expressionFunctions,c as createExpressionTokens,R as Resolver}from"./b9638e50.js";import"./8a488323.js";import{e as executeAction}from"./f042cb76.js";import{e as evaluateExpression$}from"./b4b86ec6.js";import"./66d323db.js";import{c as createFormatter}from"./3dd051e0.js";function getValidationMessage$(value,object,customValidator,config){return"unparsed"===value.state?function(value,config){const type=mx.meta.getEntity(config.entity).getAttributeType(config.attribute);switch(type){case"Enum":case"Boolean":case"ObjectReference":case"ObjectReferenceSet":return translate("mendix.lib.Validations","invalid_attribute",value,config.attribute);case"DateTime":return translate("mendix.lib.Validations","invalid_date");case"Integer":case"Long":case"Decimal":return translate("mendix.lib.Validations","invalid_number");default:throw new Error(`Attribute type ${type} is not supported.`)}}(value.value,config):function(value,config){return getTypeValidation(attributeToClientValue(value),mx.meta.getEntity(config.entity).getAttributeType(config.attribute))}(value.value,config)||(customValidator?customValidator(value.value):void 0)||(config.validation?function(value,object,validation){const resolver=new Resolver({currentObject:()=>object.old(),value:()=>attributeToExpressionVariable(value)});if(!evaluator.evaluate(validation.expression,resolver))return validation.message||translate("mendix.lib.Validations","required_field");return}(value.value,object,config.validation):void 0)}const evaluator=new Evaluator(expressionFunctions,createExpressionTokens(()=>new Date));const AttributeProperty=asProperty((config,store,widgetId)=>{const defaultFormatter=createFormatter(config.entity,config.attribute,config.formatting||{}),universe=function(config){const metaObject=mx.meta.getEntity(config.entity);switch(metaObject.getAttributeType(config.attribute)){case"Enum":return metaObject.getEnumMap(config.attribute).map(e=>e.key);case"Boolean":return[!0,!1];default:return}}(config),formatter=observable.box(defaultFormatter,{deep:!1}),invalidValue=observable.box(void 0,{deep:!1,equals:comparer.structural}),validation=observable.box(void 0);let customValidator;const submittedValue=computed(()=>{const path=config.path,rootObject=MxObject1.fromState$(store.get$(config.scope,"object")),object=path?flatMapL(rootObject,ro=>ro.getByPath$(path)):rootObject;return flatMapL(object,o=>{const attribute=o.get$(config.attribute);if(attribute.access===Access.None)return unavailable();const readOnlyState=Boolean(store.get$(pageScope,"subtreeReadonly")),computedEditable=void 0===config.isEditable||evaluateExpression$(config.isEditable,{currentObject:()=>getOrCrashL(rootObject).old()}),readOnly=attribute.access===Access.Read||readOnlyState||!computedEditable;return available({object:o,attribute:attribute.value,readOnly:readOnly})})}),submittedValueMonitor=valueMonitor(()=>submittedValue.get()),serverValidationMonitor=valueMonitor(function(){const object=mapL(submittedValue.get(),x=>x.object),validationL=mapL(object,o=>serverValidate$(`Validation of ${config.friendlyId}`,o.getGuid(),config.attribute));return getOrElseL(validationL,void 0)}),result=using(()=>[reaction(()=>store.get$(pageScope,"validationRequest"),validateCurrentValue),reaction(()=>void 0!==validation.get(),isInvalid=>store.set(widgetId,"isInvalid",isInvalid),{fireImmediately:!0}),()=>store.set(widgetId,"isInvalid",!1),reaction(()=>getOrElseL(mapL(submittedValue.get(),v=>v.readOnly?void 0:v.object.old()),void 0),object=>store.set(widgetId,"object",object),{fireImmediately:!0})],()=>{serverValidationMonitor.runIfChanged(val=>{validation.set(val?val[0]:void 0)}),submittedValueMonitor.runIfChanged(()=>{invalidValue.set(void 0),validation.set(void 0)});const submitted=submittedValue.get(),invalid=invalidValue.get(),value="available"!==submitted.status?void 0:void 0!==invalid&&"unparsed"===invalid.state?void 0:void 0!==invalid?invalid.value:submitted.value.attribute,displayValue="available"!==submitted.status?"":void 0!==invalid&&"unparsed"===invalid.state?invalid.value:formatter.get().format(void 0!==invalid?invalid.value:submitted.value.attribute);return{status:submitted.status,value:value,displayValue:displayValue,readOnly:"available"!==submitted.status||submitted.value.readOnly,validation:validation.get(),formatter:formatter.get(),universe:universe,setValidator:_customValidator=>{customValidator=_customValidator},setValue:action(newValue=>"available"!==submitted.status?noDataAvailableError(config):submitted.value.readOnly?noWriteAccessError(config):setValue({state:"parsed",value:newValue},submitted.value.object)),setTextValue:action(newValue=>"available"!==submitted.status?noDataAvailableError(config):submitted.value.readOnly?noWriteAccessError(config):setValue({state:"unparsed",value:newValue},submitted.value.object)),setFormatter:action(f=>formatter.set(f||defaultFormatter))}}),reloadable=asReloadable(()=>result.get(),v=>({value:v.value,displayValue:v.displayValue}));return()=>reloadable.get();function validateCurrentValue(){const value=submittedValue.get();if("available"!==value.status)return;const currentValue=invalidValue.get()||{state:"parsed",value:value.value.attribute};validation.set(getValidationMessage$(currentValue,value.value.object,customValidator,config))}function setValue(newValue,object){if("unparsed"===newValue.state){const parseResult=formatter.get().parse(newValue.value);newValue=parseResult.valid?{state:"parsed",value:parseResult.value}:newValue}else assertIsAttributeValue(newValue.value,config.entity,config.attribute);const newValidation=getValidationMessage$(newValue,object,customValidator,config);if(void 0!==newValidation)validation.set(newValidation),invalidValue.set(newValue);else{const oldValue=object.get$(config.attribute);comparer.structural(oldValue,accessible(newValue.value))?(invalidValue.set(void 0),validation.set(void 0)):(object.set(config.attribute,newValue.value),function(){const parameters=getActionParameters$(config.onChange.argMap,store),currentForm=ensure(store.get$(pageScope,"form"))[0];setTimeout(()=>{executeAction(config.onChange,{abortOnClientValidations:!0,abortOnServerValidations:!1,widgetIsValid:!0,currentForm:currentForm},mapValues(parameters,v=>getOrElseL(v,void 0)))},0)}())}}});function noDataAvailableError(config){mx.logger.debug(`Widget ${config.friendlyId} is attempting to change the value of attribute "${config.attribute}" of entity "${config.entity}" which is not available.`)}function noWriteAccessError(config){mx.logger.debug(`Widget ${config.friendlyId} is attempting to change the value of attribute "${config.attribute}" of entity "${config.entity}" which is not writable.`)}export{AttributeProperty};
