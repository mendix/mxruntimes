import{o as observable,e as comparer,f as computed,a as action,r as reaction}from"./481d180e.js";import{e as ensure,m as mapValues}from"./546dec4f.js";import{a as asProperty}from"./74fbff8f.js";import"./2bc24ff8.js";import{p as pageScope}from"./989522c0.js";import"./2209f9e8.js";import{b as getTypeValidation,t as translate}from"./27e4dcbd.js";import"./5b471fcd.js";import"./d2546a03.js";import"./fdd4c4ff.js";import"./63a19f1e.js";import{i as attributeToClientValue,k as attributeToExpressionVariable,l as assertIsAttributeValue}from"./2776a567.js";import"./75bfae42.js";import{E as Evaluator,e as expressionFunctions,c as createExpressionTokens,R as Resolver}from"./a95bec4a.js";import"./6f5760d1.js";import{m as mapL,g as getOrElseL,f as flatMapL,u as unavailable,a as available,c as getOrCrashL}from"./6dbf3b84.js";import{v as valueMonitor,u as using}from"./2ff2b659.js";import{M as MxObject1,A as Access,s as serverValidate$,a as accessible}from"./bb273487.js";import{g as getActionParameters$}from"./1f6ebd2f.js";import{e as executeAction}from"./32b9ee02.js";import{e as evaluateExpression$}from"./a9a42d77.js";import{c as createFormatter}from"./79b9e49c.js";function getValidationMessage$(value,object,customValidator,config){return"unparsed"===value.state?function(value,config){const type=mx.meta.getEntity(config.entity).getAttributeType(config.attribute);switch(type){case"Enum":case"Boolean":case"ObjectReference":case"ObjectReferenceSet":return translate("mendix.lib.Validations","invalid_attribute",value,config.attribute);case"DateTime":return translate("mendix.lib.Validations","invalid_date");case"Currency":return translate("mendix.lib.Validations","invalid_currency");case"Float":case"Integer":case"Long":case"Decimal":return translate("mendix.lib.Validations","invalid_number");default:throw new Error(`Attribute type ${type} is not supported.`)}}(value.value,config):function(value,config){return getTypeValidation(attributeToClientValue(value),mx.meta.getEntity(config.entity).getAttributeType(config.attribute))}(value.value,config)||(customValidator?customValidator(value.value):void 0)||(config.validation?function(value,object,validation){const resolver=new Resolver({currentObject:()=>object.old(),value:()=>attributeToExpressionVariable(value)});if(!evaluator.evaluate(validation.expression,resolver))return validation.message||translate("mendix.lib.Validations","required_field");return}(value.value,object,config.validation):void 0)}const evaluator=new Evaluator(expressionFunctions,createExpressionTokens(()=>new Date));const AttributeProperty=asProperty((config,store,widgetId)=>{const formatter=createFormatter(config.entity,config.attribute,config),universe=function(config){const metaObject=mx.meta.getEntity(config.entity);switch(metaObject.getAttributeType(config.attribute)){case"Enum":return metaObject.getEnumMap(config.attribute).map(e=>e.key);case"Boolean":return[!0,!1];default:return}}(config),formatterConfig=observable.box(formatter.defaultConfig,{deep:!1}),invalidValue=observable.box(void 0,{deep:!1,equals:comparer.structural}),validation=observable.box(void 0);let customValidator;const submittedValue=computed(()=>{const path=config.path,rootObject=MxObject1.fromState$(store.get$(config.scope,"object")),object=path?flatMapL(rootObject,ro=>ro.getByPath$(path)):rootObject;return flatMapL(object,o=>{const attribute=o.get$(config.attribute);if(attribute.access===Access.None)return unavailable();const readOnlyState=Boolean(store.get$(pageScope,"subtreeReadonly")),computedEditable=void 0===config.isEditable||evaluateExpression$(config.isEditable,{currentObject:()=>getOrCrashL(rootObject).old()}),readOnly=attribute.access===Access.Read||readOnlyState||!computedEditable;return available({object:o,attribute:attribute.value,readOnly:readOnly})})}),submittedValueMonitor=valueMonitor(()=>submittedValue.get()),serverValidationMonitor=valueMonitor(function(){const object=mapL(submittedValue.get(),x=>x.object),validationL=mapL(object,o=>serverValidate$(`Validation of ${config.friendlyId}`,o.getGuid(),config.attribute));return getOrElseL(validationL,void 0)}),result=using(()=>[reaction(()=>store.get$(pageScope,"validationRequest"),validateCurrentValue),reaction(()=>validation.get(),val=>store.set(widgetId,"isInvalid",void 0!==val),{fireImmediately:!0}),()=>store.set(widgetId,"isInvalid",!1)],()=>{serverValidationMonitor.runIfChanged(val=>{validation.set(val?val[0]:void 0)}),submittedValueMonitor.runIfChanged(()=>{invalidValue.set(void 0),validation.set(void 0)});const submitted=submittedValue.get(),invalid=invalidValue.get(),value="available"!==submitted.status?void 0:void 0!==invalid&&"unparsed"===invalid.state?void 0:void 0!==invalid?invalid.value:submitted.value.attribute,displayValue="available"!==submitted.status?"":void 0!==invalid&&"unparsed"===invalid.state?invalid.value:formatter.format(void 0!==invalid?invalid.value:submitted.value.attribute,formatterConfig.get());return{status:submitted.status,value:value,displayValue:displayValue,readOnly:"available"!==submitted.status||submitted.value.readOnly,validation:validation.get(),formatter:formatter,universe:universe,setFormatting:action(f=>formatterConfig.set(f)),setValidator:_customValidator=>{customValidator=_customValidator},setValue:action(newValue=>"available"!==submitted.status?noDataAvailableError(config):submitted.value.readOnly?noWriteAccessError(config):setValue({state:"parsed",value:newValue},submitted.value.object)),setTextValue:action(newValue=>"available"!==submitted.status?noDataAvailableError(config):submitted.value.readOnly?noWriteAccessError(config):setValue({state:"unparsed",value:newValue},submitted.value.object))}});return()=>result.get();function validateCurrentValue(){const value=submittedValue.get();if("available"!==value.status)return;const currentValue=invalidValue.get()||{state:"parsed",value:value.value.attribute};validation.set(getValidationMessage$(currentValue,value.value.object,customValidator,config))}function setValue(newValue,object){if("unparsed"===newValue.state){const parseResult=formatter.parse(newValue.value,formatterConfig.get());newValue=parseResult.valid?{state:"parsed",value:parseResult.value}:newValue}else assertIsAttributeValue(newValue.value,config.entity,config.attribute);const newValidation=getValidationMessage$(newValue,object,customValidator,config);if(void 0!==newValidation)validation.set(newValidation),invalidValue.set(newValue);else{const oldValue=object.get$(config.attribute);object.set(config.attribute,newValue.value),invalidValue.set(void 0),validation.set(void 0),comparer.structural(oldValue,accessible(newValue.value))||function(){const parameters=getActionParameters$(config.onChange.argMap,store),currentForm=ensure(store.get$(pageScope,"form"))[0];setTimeout(()=>{executeAction(config.onChange,{abortOnClientValidations:!0,abortOnServerValidations:!1,widgetIsValid:!0,currentForm:currentForm},mapValues(parameters,v=>getOrElseL(v,void 0)))},0)}()}}});function noDataAvailableError(config){mx.logger.debug(`Widget ${config.friendlyId} is attempting to change the value of attribute "${config.attribute}" of entity "${config.entity}" which is not available.`)}function noWriteAccessError(config){mx.logger.debug(`Widget ${config.friendlyId} is attempting to change the value of attribute "${config.attribute}" of entity "${config.entity}" which is not writable.`)}export{AttributeProperty};
