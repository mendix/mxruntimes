import"./d5eebceb.js";import{f as observable$$1,e as comparer$$1,h as computed$$1,a as reaction$$1,b as glitchFree}from"./6727fec8.js";import"./eed44530.js";import"./aa3ddc5d.js";import{d as ensure,m as mapValues}from"./ff203afa.js";import{s as attributeToClientValue,t as attributeToExpressionVariable,u as assertIsAttributeValue}from"./02d97a6c.js";import{c as asProperty}from"./71d615f7.js";import"./3019ed1f.js";import"./967e2ac0.js";import{j as getTypeValidation,a as translate}from"./b0b3290e.js";import"./d9069e30.js";import"./ecb7231a.js";import{b as pageScope}from"./b3fab43d.js";import"./7d776635.js";import{a as Evaluator,b as expressionFunctions,c as createExpressionTokens,d as Resolver}from"./4b8e45df.js";import"./eaafd07f.js";import{c as flatMapL,b as unavailable,d as available,e as mapL,g as getOrElseL}from"./7a470c91.js";import{d as valueMonitor,c as using}from"./12049987.js";import{b as MxObject1,c as Access,d as serverValidate,e as accessible}from"./8a992959.js";import{c as getActionParameters}from"./41f30614.js";import{a as executeAction}from"./d203c618.js";import{a as createFormatter}from"./cfa996c3.js";function getValidationMessage(value,object,customValidator,config){return"unparsed"===value.state?function(value,config){const type=mx.meta.getEntity(config.entity).getAttributeType(config.attribute);switch(type){case"Enum":case"Boolean":case"ObjectReference":case"ObjectReferenceSet":return translate("mendix.lib.Validations","invalid_attribute",value,config.attribute);case"DateTime":return translate("mendix.lib.Validations","invalid_date");case"Currency":return translate("mendix.lib.Validations","invalid_currency");case"Float":case"Integer":case"Long":case"Decimal":return translate("mendix.lib.Validations","invalid_number");default:throw new Error(`Attribute type ${type} is not supported.`)}}(value.value,config):function(value,config){return getTypeValidation(attributeToClientValue(value),mx.meta.getEntity(config.entity).getAttributeType(config.attribute))}(value.value,config)||(customValidator?customValidator(value.value):void 0)||(config.validation?function(value,object,validation){const resolver=new Resolver({currentObject:()=>object.old(),value:()=>attributeToExpressionVariable(value)});if(!evaluator.evaluate(validation.expression,resolver))return validation.message||translate("mendix.lib.Validations","required_field");return}(value.value,object,config.validation):void 0)}const evaluator=new Evaluator(expressionFunctions,createExpressionTokens(()=>new Date));const AttributeProperty=asProperty((config,store,widgetId)=>{const formatter=createFormatter(config.entity,config.attribute,config),universe=function(config){const metaObject=mx.meta.getEntity(config.entity);switch(metaObject.getAttributeType(config.attribute)){case"Enum":return metaObject.getEnumMap(config.attribute).map(e=>e.key);case"Boolean":return[!0,!1];default:return}}(config),formatterConfig=observable$$1.box(formatter.defaultConfig,{deep:!1}),invalidValue=observable$$1.box(void 0,{deep:!1,equals:comparer$$1.structural}),validation=observable$$1.box(void 0);let customValidator;const submittedValue=computed$$1(()=>{const path=config.path,rootObject=MxObject1.fromState(store.get(config.scope,"object")),object=path?flatMapL(rootObject,ro=>ro.getByPath(path)):rootObject;return flatMapL(object,o=>{const attribute=o.get(config.attribute);if(attribute.access===Access.None)return unavailable();const readOnlyState=Boolean(store.get(pageScope,"subtreeReadonly")),readOnly=attribute.access===Access.Read||readOnlyState||config.readOnly;return available({object:o,attribute:attribute.value,readOnly:readOnly})})}),submittedValueMonitor=valueMonitor(()=>submittedValue.get()),serverValidationMonitor=valueMonitor(function(){const object=mapL(submittedValue.get(),x=>x.object),validationL=mapL(object,o=>serverValidate(`Validation of ${config.friendlyId}`,o.getGuid(),config.attribute));return getOrElseL(validationL,void 0)}),result=using(()=>[reaction$$1(()=>store.get(pageScope,"validationRequest"),validateCurrentValue),reaction$$1(()=>validation.get(),val=>store.set(widgetId,"isInvalid",void 0!==val),{fireImmediately:!0}),()=>store.set(widgetId,"isInvalid",!1)],()=>{serverValidationMonitor.runIfChanged(val=>{validation.set(val?val[0]:void 0)}),submittedValueMonitor.runIfChanged(()=>{invalidValue.set(void 0),validation.set(void 0)});const submitted=submittedValue.get(),invalid=invalidValue.get(),value="available"!==submitted.status?void 0:void 0!==invalid&&"unparsed"===invalid.state?void 0:void 0!==invalid?invalid.value:submitted.value.attribute,displayValue="available"!==submitted.status?"":void 0!==invalid&&"unparsed"===invalid.state?invalid.value:formatter.format(void 0!==invalid?invalid.value:submitted.value.attribute,formatterConfig.get());return{status:submitted.status,value:value,displayValue:displayValue,readOnly:"available"!==submitted.status||submitted.value.readOnly,validation:validation.get(),formatter:formatter,universe:universe,setFormatting:glitchFree(f=>formatterConfig.set(f)),setValidator:_customValidator=>{customValidator=_customValidator},setValue:glitchFree(newValue=>"available"!==submitted.status?noDataAvailableError(config):submitted.value.readOnly?noWriteAccessError(config):setValue({state:"parsed",value:newValue},submitted.value.object)),setTextValue:glitchFree(newValue=>"available"!==submitted.status?noDataAvailableError(config):submitted.value.readOnly?noWriteAccessError(config):setValue({state:"unparsed",value:newValue},submitted.value.object))}});return()=>result.get();function validateCurrentValue(){const value=submittedValue.get();if("available"!==value.status)return;const currentValue=invalidValue.get()||{state:"parsed",value:value.value.attribute};validation.set(getValidationMessage(currentValue,value.value.object,customValidator,config))}function setValue(newValue,object){if("unparsed"===newValue.state){const parseResult=formatter.parse(newValue.value,formatterConfig.get());newValue=parseResult.valid?{state:"parsed",value:parseResult.value}:newValue}else assertIsAttributeValue(newValue.value,config.entity,config.attribute);const newValidation=getValidationMessage(newValue,object,customValidator,config);if(void 0!==newValidation)validation.set(newValidation),invalidValue.set(newValue);else{const oldValue=object.get(config.attribute);object.set(config.attribute,newValue.value),invalidValue.set(void 0),validation.set(void 0),comparer$$1.structural(oldValue,accessible(newValue.value))||function(){const parameters=getActionParameters(config.onChange.argMap,store);executeAction(config.onChange,{abortOnClientValidations:!0,abortOnServerValidations:!1,widgetIsValid:!0,currentForm:ensure(store.get(pageScope,"form"))[0]},mapValues(parameters,v=>getOrElseL(v,void 0)))}()}}});function noDataAvailableError(config){mx.logger.debug(`Widget ${config.friendlyId} is attempting to change the value of attribute "${config.attribute}" of entity "${config.entity}" which is not available.`)}function noWriteAccessError(config){mx.logger.debug(`Widget ${config.friendlyId} is attempting to change the value of attribute "${config.attribute}" of entity "${config.entity}" which is not writable.`)}export{AttributeProperty};
