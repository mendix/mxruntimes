import{A as AssertionError}from"./b0fce5df.js";import{e as ensure,r as isString,t as isArrayOf,h as crash,v as containsKey,g as getOrElseL,l as loading,s as subscriptionDependency}from"./764abf4b.js";import{Big}from"big.js";import{r as runtimeValueToAttributeValue,q as delocalizeDate,s as localizeDate,M as MxObject,h as clientToAttributeValue}from"./8f1f3520.js";import{c as toMendixPattern,b as parseDate,g as getLocale,a as formatDate,d as addMilliseconds,e as addSeconds,h as addMinutes,i as addHours,j as addDays,k as addWeeks,l as addMonths,m as addYears,n as startOfSecond,o as startOfMinute,q as startOfHour,r as startOfDay,u as startOfMonth,v as startOfYear,p as parseNumber,f as formatNumber,w as getDateFnsLocale,x as endOfMinute,y as endOfHour,z as endOfDay,A as startOfWeek,B as endOfWeek,C as endOfMonth,D as endOfYear}from"./28ba9e42.js";function operationErrorText(operator,...args){return`Operator ${operator} not supported in expression ${operator}(${args.join(", ")})`}const addFunctionMap={addMilliseconds:addMilliseconds,addSeconds:addSeconds,addMinutes:addMinutes,addHours:addHours,addDays:addDays,addWeeks:addWeeks,addMonths:addMonths,addYears:addYears},trimFunctionMap={trimToSeconds:startOfSecond,trimToMinutes:startOfMinute,trimToHours:startOfHour,trimToDays:startOfDay,trimToMonths:startOfMonth,trimToYears:startOfYear},expressionDateFunctions=Object.assign(Object.assign(Object.assign({dateTime:(...args)=>evaluateCreateDateTime(args,!1,operationErrorText("dateTime",...args)),dateTimeUTC:(...args)=>evaluateCreateDateTime(args,!0,operationErrorText("dateTimeUTC",...args)),parseDateTime:(...args)=>evaluateParseDateTime(args,!1,operationErrorText("parseDateTime",...args)),parseDateTimeUTC:(...args)=>evaluateParseDateTime(args,!0,operationErrorText("parseDateTimeUTC",...args)),formatDate:arg=>evaluateFormatDate(arg,{type:"date"},!1,operationErrorText("formatDate",arg)),formatDateUTC:arg=>evaluateFormatDate(arg,{type:"date"},!0,operationErrorText("formatDateUTC",arg)),formatTime:arg=>evaluateFormatDate(arg,{type:"time"},!1,operationErrorText("formatTime",arg)),formatTimeUTC:arg=>evaluateFormatDate(arg,{type:"time"},!0,operationErrorText("formatTimeUTC",arg)),formatDateTime:(...args)=>evaluateFormatDate(args[0],toFormatterConfig(args[1]),!1,operationErrorText("formatDateTime",...args)),formatDateTimeUTC:(...args)=>evaluateFormatDate(args[0],toFormatterConfig(args[1]),!0,operationErrorText("formatDateTimeUTC",...args))},createExpressionFunctionCollection({millisecondsBetween:1,secondsBetween:1e3,minutesBetween:6e4,hoursBetween:36e5,daysBetween:864e5,weeksBetween:6048e5},(function(args,scale,errorText){const firstDate=args[0],secondDate=args[1];if(firstDate instanceof Date&&secondDate instanceof Date){return new Big(firstDate.getTime()).sub(secondDate.getTime()).abs().div(scale)}throw new Error(errorText)}),!1)),createExpressionFunctionCollection(addFunctionMap,(function(args,addFunction,errorText,utc){let date=args[0];const add=args[1];if(date instanceof Date&&add instanceof Big){utc&&(date=localizeDate(date));let newDate=addFunction(date,Number(add));return utc&&(newDate=delocalizeDate(newDate)),newDate}throw new Error(errorText)}),!0)),createExpressionFunctionCollection(trimFunctionMap,(function(args,trimFunction,errorText,utc){let date=args[0];if(date instanceof Date){utc&&(date=localizeDate(date));let newDate=trimFunction(date);return utc&&(newDate=delocalizeDate(newDate)),newDate}throw new Error(errorText)}),!0));function evaluateCreateDateTime(args,utc,errorText){const numbers=args.map(arg=>{if(arg instanceof Big)return Number(arg);throw new Error(errorText)});return 1===numbers.length&&numbers.push(1),numbers[1]=numbers[1]-1,utc?new Date(Date.UTC(...numbers)):new Date(...numbers)}function evaluateParseDateTime(args,utc,errorText){const[value,pattern,fallback]=args;if("string"==typeof value&&"string"==typeof pattern){const parsed=parseDate(value.trim(),{type:"custom",pattern:toMendixPattern(pattern.trim())});if(parsed instanceof Date)return utc?delocalizeDate(parsed):parsed;if(fallback instanceof Date)return fallback;throw new Error(`Unparseable date: "${value}"`)}throw new Error(errorText)}function evaluateFormatDate(arg,formatterConfig,utc,errorText){if(arg instanceof Date)return utc&&(arg=localizeDate(arg)),"custom"!==formatterConfig.type&&(formatterConfig={type:"custom",pattern:getLocale().nanoflowPatterns[formatterConfig.type]}),formatDate(arg,formatterConfig);throw new Error(errorText)}function createExpressionFunctionCollection(functionMap,evaluator,utcVariant){return Object.keys(functionMap).reduce((collection,name)=>{const parameter=functionMap[name];if(collection[name]=(...args)=>evaluator(args,parameter,operationErrorText(name,...args)),utcVariant){const utcName=`${name}UTC`;collection[utcName]=(...args)=>evaluator(args,parameter,operationErrorText(utcName,...args),!0)}return collection},{})}function toFormatterConfig(pattern){return"string"==typeof pattern?{type:"custom",pattern:toMendixPattern(pattern)}:{type:"datetime"}}const expressionListFunctions={_newList:()=>[],_toList:arg1=>asList(arg1,operationErrorText("_toList",arg1)),_addToList(arg1,arg2){const arr1=asList(arg1,operationErrorText("_addToList",arg1,arg2)),arr2=asList(arg2,operationErrorText("_addToList",arg1,arg2));return arr1.concat(arr2.filter(guid=>!arr1.includes(guid)))},_removeFromList(arg1,arg2){const arr1=asList(arg1,operationErrorText("_removeFromList",arg1,arg2)),arr2=asList(arg2,operationErrorText("_removeFromList",arg1,arg2));return arr1.filter(guid=>!arr2.includes(guid))},_intersectLists(arg1,arg2){const arr1=asList(arg1,operationErrorText("_intersectLists",arg1,arg2)),arr2=asList(arg2,operationErrorText("_intersectLists",arg1,arg2));return arr1.filter(guid=>arr2.includes(guid))},_listContains(arg1,arg2){const arr1=asList(arg1,operationErrorText("_listContains",arg1,arg2)),arr2=asList(arg2,operationErrorText("_listContains",arg1,arg2));return arr2.length>0&&arr2.every(guid=>arr1.includes(guid))},_head(arg1){if(arg1 instanceof Array)return arg1.length>0?arg1[0]:void 0;if(void 0!==arg1)throw new Error(operationErrorText("_head",arg1))}};function asList(arg,errorText){if(arg instanceof Array)return arg;if(isString(arg))return arg.length>0?[arg]:[];if(void 0===arg)return[];throw new Error(errorText)}const expressionLogicFunctions={not:arg=>!arg,"=":(arg1,arg2)=>arg1 instanceof Big&&arg2 instanceof Big?arg1.eq(arg2):arg1 instanceof Date&&arg2 instanceof Date?arg1.getTime()===arg2.getTime():"string"==typeof arg1||"string"==typeof arg2?(arg1||"")===(arg2||""):arg1 instanceof Array&&arg2 instanceof Array?arg1.length===arg2.length&&arg1.every(elem=>arg2.includes(elem)):arg1 instanceof Array&&void 0===arg2?0===arg1.length:void 0===arg1&&arg2 instanceof Array?0===arg2.length:arg1===arg2,"!=":(arg1,arg2)=>!expressionLogicFunctions["="](arg1,arg2),">"(arg1,arg2){if(arg1 instanceof Big&&arg2 instanceof Big)return arg1.gt(arg2);if(arg1 instanceof Date&&arg2 instanceof Date)return arg1.getTime()>arg2.getTime();if(void 0===arg1||void 0===arg2)throw new Error(operationErrorText(">",arg1,arg2));return arg1>arg2},">=":(arg1,arg2)=>expressionLogicFunctions["="](arg1,arg2)||expressionLogicFunctions[">"](arg1,arg2),"<"(arg1,arg2){if(arg1 instanceof Big&&arg2 instanceof Big)return arg1.lt(arg2);if(arg1 instanceof Date&&arg2 instanceof Date)return arg1.getTime()<arg2.getTime();if(void 0===arg1||void 0===arg2)throw new Error(operationErrorText("<",arg1,arg2));return arg1<arg2},"<=":(arg1,arg2)=>expressionLogicFunctions["="](arg1,arg2)||expressionLogicFunctions["<"](arg1,arg2)},expressionMathFunctions={"+"(arg1,arg2){if(arg1 instanceof Big&&arg2 instanceof Big)return arg1.plus(arg2);if("string"==typeof arg1)return arg1+(void 0!==arg2?arg2.toString():"");if("string"==typeof arg2)return(void 0!==arg1?arg1.toString():"")+arg2;throw new Error(operationErrorText("+",arg1,arg2))},"-"(arg1,arg2){if(1===arguments.length&&void 0!==arg1)return arg1.times(-1);if(void 0!==arg1&&void 0!==arg2)return arg1.minus(arg2);throw new Error(operationErrorText("-",arg1,arg2))},"*"(arg1,arg2){if(void 0!==arg1&&void 0!==arg2)return arg1.times(arg2);throw new Error(operationErrorText("*",arg1,arg2))},div(arg1,arg2){if(void 0!==arg1&&void 0!==arg2)return arg1.div(arg2);throw new Error(operationErrorText("div",arg1,arg2))},mod(arg1,arg2){if(void 0!==arg1&&void 0!==arg2)return arg1.mod(arg2);throw new Error(operationErrorText("mod",arg1,arg2))},":":(arg1,arg2)=>expressionMathFunctions.div(arg1,arg2),max(...args){if(args[0]instanceof Big)return args.reduce((n1,n2)=>n1.gt(n2)?n1:n2);if(args[0]instanceof Date)return args.reduce((d1,d2)=>d1.getTime()>d2.getTime()?d1:d2);throw new Error(operationErrorText("max",...args))},min(...args){if(args[0]instanceof Big)return args.reduce((n1,n2)=>n1.lt(n2)?n1:n2);if(args[0]instanceof Date)return args.reduce((d1,d2)=>d1.getTime()<d2.getTime()?d1:d2);throw new Error(operationErrorText("min",...args))},round(arg,dp){if(arg instanceof Big)return arg.round(void 0===dp?0:Number(dp));throw new Error(operationErrorText("round",arg))},random:()=>new Big(Math.random()),floor(arg){if(arg instanceof Big){const fractional=arg.mod(1);return fractional.eq(0)?arg.eq(-0)?arg.abs():arg:arg.minus(fractional).minus(arg.lt(0)?1:0)}throw new Error(operationErrorText("floor",arg))},ceil(arg){if(arg instanceof Big){const result=expressionMathFunctions.floor(arg.times(-1));return result.eq(0)?result:result.times(-1)}throw new Error(operationErrorText("ceil",arg))},pow(arg,exponent){if(arg instanceof Big&&exponent instanceof Big)return arg.pow(Number(exponent));throw new Error(operationErrorText("pow",arg))},abs(arg){if(arg instanceof Big)return arg.abs();throw new Error(operationErrorText("abs",arg))}},expressionStringFunctions={toUpperCase:arg1=>asString(arg1).toUpperCase(),toLowerCase:arg1=>asString(arg1).toLowerCase(),trim:arg1=>asString(arg1).trim(),contains:(arg1,arg2)=>asString(arg1).includes(asString(arg2)),startsWith:(arg1,arg2)=>(arg1=asString(arg1),arg2=asString(arg2),arg1.substr(0,arg2.length)===arg2),endsWith:(arg1,arg2)=>(arg1=asString(arg1),arg2=asString(arg2),arg1.substr(arg1.length-arg2.length)===arg2),substring(arg1,arg2,arg3){if(arg1=asString(arg1),arg3=arg3,void 0!==(arg2=arg2)&&arg2.gte(0)){if(2===arguments.length)return arg1.substr(Number(arg2));if(void 0!==arg3&&arg3.gte(0))return arg1.substr(Number(arg2),Number(arg3))}throw new Error(operationErrorText("substring",arg1,arg2,arg3))},find(arg1,arg2,arg3){if(arg1=asString(arg1),arg2=asString(arg2),2===arguments.length)return new Big(arg1.indexOf(arg2));if(void 0!==arg3)return new Big(arg1.indexOf(arg2,Number(arg3)));throw new Error(operationErrorText("find",arg1,arg2,arg3))},findLast(arg1,arg2,arg3){if(arg1=asString(arg1),arg2=asString(arg2),2===arguments.length)return new Big(arg1.lastIndexOf(arg2));if(void 0!==arg3)return new Big(arg1.lastIndexOf(arg2,Number(arg3)));throw new Error(operationErrorText("findLast",arg1,arg2,arg3))},length:arg1=>new Big(asString(arg1).length),urlEncode:arg1=>encodeURIComponent(asString(arg1)).replace("%20","+"),urlDecode:arg1=>decodeURIComponent(asString(arg1).replace("+","%20")),isMatch(arg1,arg2){if(void 0!==arg2)return new RegExp(`^(${arg2})$`).test(asString(arg1));throw new Error(operationErrorText("isMatch",arg1,arg2))},replaceFirst(arg1,arg2,arg3){if(void 0!==arg2&&void 0!==arg3){const escapedForReplaceValue=arg3.replace(/\$/g,"$$$$");return asString(arg1).replace(new RegExp(arg2),escapedForReplaceValue)}throw new Error(operationErrorText("replaceFirst",arg1,arg2))},replaceAll(arg1,arg2,arg3){if(void 0!==arg2&&void 0!==arg3){const escapedForReplaceValue=arg3.replace(/\$/g,"$$$$");return asString(arg1).replace(new RegExp(arg2,"g"),escapedForReplaceValue)}throw new Error(operationErrorText("replaceAll",arg1,arg2))}};function asString(arg){return void 0===arg?"":arg}const expressionFunctions=Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},expressionDateFunctions),expressionListFunctions),expressionLogicFunctions),expressionMathFunctions),expressionStringFunctions),{toString:arg1=>arg1 instanceof Big?arg1.toString():void 0===arg1?"":arg1 instanceof Date?formatDate(arg1,{type:"datetime"}):String(arg1),parseInteger(arg,defaultValue){if("string"==typeof arg){if(/^-?\d+$/.test(arg)){const result=Big(arg);return result.eq(-0)?result.abs():result}if(void 0===defaultValue)throw new Error(`Not parsable to Integer: ${arg}`);return defaultValue}throw new Error(operationErrorText("parseInteger",arg))},parseDecimal(arg,defaultValue){if("string"==typeof arg){const parsed=parseNumber(arg);if(void 0===parsed&&void 0===defaultValue)throw new Error(`Not parsable to Decimal: ${arg}`);return void 0===parsed?defaultValue:parsed}throw new Error(operationErrorText("parseDecimal",arg))},formatDecimal(arg){if(arg instanceof Big)return formatNumber(arg);throw new Error(operationErrorText("formatDecimal",arg))},isNew:arg1=>void 0!==arg1&&mx.data.isNew(arg1),isSynced(arg1){if(void 0!==arg1)return!mx.data.isDirty(arg1);throw new Error(operationErrorText("isSynced",arg1))},_hasSomeRole:(...args)=>mx.session.hasSomeRole(args)});var isArray=Array.isArray,keyList=Object.keys,hasProp=Object.prototype.hasOwnProperty,fastDeepEqual=function equal(a,b){if(a===b)return!0;if(a&&b&&"object"==typeof a&&"object"==typeof b){var i,length,key,arrA=isArray(a),arrB=isArray(b);if(arrA&&arrB){if((length=a.length)!=b.length)return!1;for(i=length;0!=i--;)if(!equal(a[i],b[i]))return!1;return!0}if(arrA!=arrB)return!1;var dateA=a instanceof Date,dateB=b instanceof Date;if(dateA!=dateB)return!1;if(dateA&&dateB)return a.getTime()==b.getTime();var regexpA=a instanceof RegExp,regexpB=b instanceof RegExp;if(regexpA!=regexpB)return!1;if(regexpA&&regexpB)return a.toString()==b.toString();var keys=keyList(a);if((length=keys.length)!==keyList(b).length)return!1;for(i=length;0!=i--;)if(!hasProp.call(b,keys[i]))return!1;for(i=length;0!=i--;)if(!equal(a[key=keys[i]],b[key]))return!1;return!0}return a!=a&&b!=b};class AccessDeniedError extends Error{constructor(variableName,entityName,attributeName){super(`Unable to get a member from variable $${variableName}, because you do not have sufficient permissions to "${entityName}.${attributeName}".`),this.variableName=variableName,this.entityName=entityName,this.attributeName=attributeName,Object.setPrototypeOf(this,AccessDeniedError.prototype)}}class EmptyVariableAccessError extends Error{constructor(variableName){super(`Unable to get a member from an empty variable $${variableName}.`),this.variableName=variableName,Object.setPrototypeOf(this,EmptyVariableAccessError.prototype)}}class Resolver{constructor(getVariable){this.getVariable=getVariable,this.dependencies=[]}resolve(variable,path){return void 0!==path?this.resolveAttribute(variable,path):this.resolveVariable(variable)}getDependencies(){return this.dependencies.slice()}resolveVariable(name){const value=this.getVariable(name);if(value instanceof MxObject)return this.addDependency({guid:value.getGuid()}),value.getGuid();if(isArrayOf(MxObject,value)){const guids=value.map(obj=>obj.getGuid());return guids.forEach(guid=>this.addDependency({guid:guid})),guids}return value}resolveAttribute(variable,attribute){const obj=this.getVariable(variable);if(void 0===obj)throw new EmptyVariableAccessError(variable);if(!(obj instanceof MxObject))throw new AssertionError;if(!obj.has(attribute))throw new AccessDeniedError(variable,obj.getEntity(),attribute);return this.addDependency({guid:obj.getGuid()}),this.addDependency({guid:obj.getGuid(),attr:attribute}),clientToAttributeValue(obj.get(attribute),obj.getAttributeType(attribute))}addDependency(dependency){this.dependencies.find(dep=>fastDeepEqual(dep,dependency))||this.dependencies.push(dependency)}}const funcMap={beginOfCurrentMinute:startOfMinute,endOfCurrentMinute:endOfMinute,beginOfCurrentHour:startOfHour,endOfCurrentHour:endOfHour,beginOfCurrentDay:startOfDay,endOfCurrentDay:endOfDay,beginOfCurrentWeek:startOfWeek,endOfCurrentWeek:endOfWeek,beginOfCurrentMonth:startOfMonth,endOfCurrentMonth:endOfMonth,beginOfCurrentYear:startOfYear,endOfCurrentYear:endOfYear};function createExpressionTokens(getNow){const tokensCollection={currentUser:()=>mx.session.getUserId(),currentDateTime:getNow};return Object.keys(funcMap).forEach(exposedName=>{const func=funcMap[exposedName];tokensCollection[exposedName]=()=>func(getNow(),{locale:getDateFnsLocale()}),tokensCollection[exposedName+"UTC"]=()=>delocalizeDate(func(localizeDate(getNow())))}),tokensCollection}const evaluator=new class{constructor(expressionFunctions,expressionTokens,getConstants){this.expressionFunctions=expressionFunctions,this.expressionTokens=expressionTokens,this.getConstants=getConstants}evaluate(expr,resolver){switch(expr.type){case"function":if(!this.expressionFunctions[expr.name])throw new Error(`Function ${expr.name} is not known`);const values=expr.parameters.map(exp=>this.evaluate(exp,resolver));return this.expressionFunctions[expr.name].apply(null,values);case"literal":return"number"==typeof expr.value?new Big(expr.value):null===expr.value?void 0:expr.value;case"variable":return void 0!==expr.path?resolver.resolve(expr.variable,expr.path):resolver.resolve(expr.variable);case"conditional":return this.evaluate(expr.condition,resolver)?this.evaluate(expr.then,resolver):this.evaluate(expr.else,resolver);case"token":if(!this.expressionTokens[expr.name])throw new Error(`Token ${expr.name} is not known`);return this.expressionTokens[expr.name]();case"constant":const constant=ensure(this.getConstants().find(({name:name})=>expr.name===name));return runtimeValueToAttributeValue(constant.value,constant.type)}}}(expressionFunctions,createExpressionTokens(()=>new Date),()=>mx.session.getConstants());function evaluateExpression(expression,getVariable,outDependencies=[]){const resolver=new Resolver(getVariable);try{return evaluator.evaluate(expression,resolver)}finally{outDependencies.push(...resolver.getDependencies())}}function evaluateFormExpression$(expression,store,description,extraArgs={}){const dependencies=[];try{return evaluateExpression(expression.expr,param=>containsKey(param,extraArgs)?extraArgs[param]():getOrElseL(store.get$(expression.args[param],"object")||loading(),void 0),dependencies)}finally{dependencies.map(dependency=>subscriptionDependency(description,dependency)).forEach(atom=>atom.reportObserved())}}function evaluateFlowExpression(expr,scope,resultKind){const exprResult=evaluateExpression(expr,name=>scope.get(name));switch(resultKind){case"primitive":return exprResult;case"list":return Array.isArray(exprResult)?scope.mapGuidsToObjects(exprResult):void 0===exprResult?[]:crash();case"object":return"string"==typeof exprResult?scope.mapGuidsToObjects([exprResult])[0]:void 0===exprResult?void 0:crash()}}export{AccessDeniedError as A,EmptyVariableAccessError as E,evaluateFlowExpression as a,evaluateFormExpression$ as b,createExpressionTokens as c,expressionFunctions as e};
