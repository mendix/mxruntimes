import{h as isString,A as AssertionError,j as isArrayOf}from"./546dec4f.js";import{B as Big}from"./2bc24ff8.js";import{l as addMilliseconds,m as addSeconds,n as addMinutes,o as addHours,e as addDays,q as addWeeks,c as addMonths,b as addYears,r as startOfSecond,t as startOfMinute,u as startOfHour,v as startOfDay,w as startOfMonth,x as startOfYear,y as endOfMinute,z as endOfHour,A as endOfDay,B as startOfWeek,C as endOfWeek,D as endOfMonth,E as endOfYear}from"./5b471fcd.js";import{M as MxObject,e as clientToAttributeValue}from"./2776a567.js";class Evaluator{constructor(expressionFunctions,expressionTokens){this.expressionFunctions=expressionFunctions,this.expressionTokens=expressionTokens}evaluate(expr,resolver){switch(expr.type){case"function":if(!this.expressionFunctions[expr.name])throw new Error(`Function ${expr.name} is not known`);const values=expr.parameters.map(exp=>this.evaluate(exp,resolver));return this.expressionFunctions[expr.name].apply(null,values);case"literal":return"number"==typeof expr.value?new Big(expr.value):null===expr.value?void 0:expr.value;case"variable":return void 0!==expr.path?resolver.resolve(expr.variable,expr.path):resolver.resolve(expr.variable);case"conditional":return this.evaluate(expr.condition,resolver)?this.evaluate(expr.then,resolver):this.evaluate(expr.else,resolver);case"token":if(!this.expressionTokens[expr.name])throw new Error(`Token ${expr.name} is not known`);return this.expressionTokens[expr.name]()}}}function toDateFnsPattern(mendixPattern){return replaceSymbols(mendixPattern,[{existing:"yyy",replacement:"yyyy"},{existing:"E",replacement:"e"},{existing:"EE",replacement:"ee"},{existing:"YYY",replacement:"YYYY"}])}function toMendixPattern(runtimePattern){return replaceSymbols(runtimePattern,[{existing:"GGGG",replacement:"GGG"},{existing:"GGGGG",replacement:"GGG"},{existing:"GGGGGG",replacement:"GGG"},{existing:"MMMMM",replacement:"MMMM"},{existing:"E",replacement:"EEE"},{existing:"EE",replacement:"EEE"},{existing:"EEEEE",replacement:"EEEE"},{existing:"EEEEEE",replacement:"EEEE"},{existing:"S",replacement:"SSS"},{existing:"SS",replacement:"SSS"},{existing:"SSSS",replacement:"'0'SSS"},{existing:"SSSSS",replacement:"'00'SSS"},{existing:"SSSSSS",replacement:"'000'SSS"},{existing:"W",replacement:"'W'"},{existing:"WW",replacement:"'WW'"},{existing:"WWW",replacement:"'WWW'"},{existing:"WWWW",replacement:"'WWWW'"},{existing:"WWWWW",replacement:"'WWWWW'"},{existing:"WWWWWW",replacement:"'WWWWWW'"},{existing:"F",replacement:"'F'"},{existing:"FF",replacement:"'FF'"},{existing:"FFF",replacement:"'FFF'"},{existing:"FFFF",replacement:"'FFFF'"},{existing:"FFFFF",replacement:"'FFFFF'"},{existing:"FFFFFF",replacement:"'FFFFFF'"},{existing:"u",replacement:"'u'"},{existing:"uu",replacement:"'uu'"},{existing:"uuu",replacement:"'uuu'"},{existing:"uuuu",replacement:"'uuuu'"},{existing:"uuuuu",replacement:"'uuuuu'"},{existing:"uuuuuu",replacement:"'uuuuuu'"},{existing:"Z",replacement:"'Z'"},{existing:"ZZ",replacement:"'ZZ'"},{existing:"ZZZ",replacement:"'ZZZ'"},{existing:"ZZZZ",replacement:"'ZZZZ'"},{existing:"ZZZZZ",replacement:"'ZZZZZ'"},{existing:"ZZZZZZ",replacement:"'ZZZZZZ'"},{existing:"z",replacement:"'z'"},{existing:"zz",replacement:"'zz'"},{existing:"zzz",replacement:"'zzz'"},{existing:"zzzz",replacement:"'zzzz'"},{existing:"zzzzz",replacement:"'zzzzz'"},{existing:"zzzzzz",replacement:"'zzzzzz'"},{existing:"X",replacement:"'X'"},{existing:"XX",replacement:"'XX'"},{existing:"XXX",replacement:"'XXX'"},{existing:"XXXX",replacement:"'XXXX'"},{existing:"XXXXX",replacement:"'XXXXX'"},{existing:"XXXXXX",replacement:"'XXXXXX'"}])}function replaceSymbols(haystack,symbols){const result=haystack.match(/''|'(?:''|[^'])+(?:'|$)|(.)\1*/g)||[];return symbols.reduce((symbolGroups,{existing:existing,replacement:replacement})=>symbolGroups.map(value=>value===existing?replacement:value),result).join("")}function localizeDate(date){return new Date(date.getTime()+getUtcOffsetMillis(date))}function delocalizeDate(date){return new Date(date.getTime()-getUtcOffsetMillis(date))}function getUtcOffsetMillis(date){const offsetMinutes=date.getTimezoneOffset(),offsetMillis=6e4*offsetMinutes;return offsetMinutes%60==-19?offsetMillis-1e3*function(){const date=new Date;return date.setFullYear(1937,5,30),date.setHours(0,0,0,0),-0xeed859aca0===date.getTime()?32:0}():offsetMillis}function operationErrorText(operator,...args){return`Operator ${operator} not supported in expression ${operator}(${args.join(", ")})`}const addFunctionMap={addMilliseconds:addMilliseconds,addSeconds:addSeconds,addMinutes:addMinutes,addHours:addHours,addDays:addDays,addWeeks:addWeeks,addMonths:addMonths,addYears:addYears},trimFunctionMap={trimToSeconds:startOfSecond,trimToMinutes:startOfMinute,trimToHours:startOfHour,trimToDays:startOfDay,trimToMonths:startOfMonth,trimToYears:startOfYear},expressionDateFunctions=Object.assign({dateTime:(...args)=>evaluateCreateDateTime(args,!1,operationErrorText("dateTime",...args)),dateTimeUTC:(...args)=>evaluateCreateDateTime(args,!0,operationErrorText("dateTimeUTC",...args)),parseDateTime:(...args)=>evaluateParseDateTime(args,!1,operationErrorText("parseDateTime",...args)),parseDateTimeUTC:(...args)=>evaluateParseDateTime(args,!0,operationErrorText("parseDateTimeUTC",...args)),formatDate:arg=>evaluateFormatDate(arg,{type:"date"},!1,operationErrorText("formatDate",arg)),formatDateUTC:arg=>evaluateFormatDate(arg,{type:"date"},!0,operationErrorText("formatDateUTC",arg)),formatTime:arg=>evaluateFormatDate(arg,{type:"time"},!1,operationErrorText("formatTime",arg)),formatTimeUTC:arg=>evaluateFormatDate(arg,{type:"time"},!0,operationErrorText("formatTimeUTC",arg)),formatDateTime:(...args)=>evaluateFormatDate(args[0],toFormatterConfig(args[1]),!1,operationErrorText("formatDateTime",...args)),formatDateTimeUTC:(...args)=>evaluateFormatDate(args[0],toFormatterConfig(args[1]),!0,operationErrorText("formatDateTimeUTC",...args))},createExpressionFunctionCollection({millisecondsBetween:1,secondsBetween:1e3,minutesBetween:6e4,hoursBetween:36e5,daysBetween:864e5,weeksBetween:6048e5},function(args,scale,errorText){const firstDate=args[0],secondDate=args[1];if(firstDate instanceof Date&&secondDate instanceof Date){const difference=new Big(firstDate.getTime()).sub(secondDate.getTime()).abs();return difference.div(scale)}throw new Error(errorText)},!1),createExpressionFunctionCollection(addFunctionMap,function(args,addFunction,errorText,utc){let date=args[0];const add=args[1];if(date instanceof Date&&add instanceof Big){utc&&(date=localizeDate(date));let newDate=addFunction(date,Number(add));return utc&&(newDate=delocalizeDate(newDate)),newDate}throw new Error(errorText)},!0),createExpressionFunctionCollection(trimFunctionMap,function(args,trimFunction,errorText,utc){let date=args[0];if(date instanceof Date){utc&&(date=localizeDate(date));let newDate=trimFunction(date);return utc&&(newDate=delocalizeDate(newDate)),newDate}throw new Error(errorText)},!0));function evaluateCreateDateTime(args,utc,errorText){const numbers=args.map(arg=>{if(arg instanceof Big)return Number(arg);throw new Error(errorText)});return 1===numbers.length&&numbers.push(1),numbers[1]=numbers[1]-1,utc?new Date(Date.UTC(...numbers)):new Date(...numbers)}function evaluateParseDateTime(args,utc,errorText){const[value,pattern,fallback]=args;if("string"==typeof value&&"string"==typeof pattern){const parsed=mx.parser.parseValue(value.trim(),"DateTime",{type:"custom",pattern:toMendixPattern(pattern.trim())});if(parsed instanceof Date)return utc?delocalizeDate(parsed):parsed;if(fallback instanceof Date)return fallback;throw new Error(`Unparseable date: "${value}"`)}throw new Error(errorText)}function evaluateFormatDate(arg,formatterConfig,utc,errorText){if(arg instanceof Date)return utc&&(arg=localizeDate(arg)),mx.parser.formatValue(arg.getTime(),"DateTime",formatterConfig);throw new Error(errorText)}function createExpressionFunctionCollection(functionMap,evaluator,utcVariant){return Object.keys(functionMap).reduce((collection,name)=>{const parameter=functionMap[name];if(collection[name]=(...args)=>evaluator(args,parameter,operationErrorText(name,...args)),utcVariant){const utcName=`${name}UTC`;collection[utcName]=(...args)=>evaluator(args,parameter,operationErrorText(utcName,...args),!0)}return collection},{})}function toFormatterConfig(pattern){return"string"==typeof pattern?{type:"custom",pattern:toMendixPattern(pattern)}:{type:"datetime"}}const expressionListFunctions={_newList:()=>[],_toList:arg1=>asList(arg1,operationErrorText("_toList",arg1)),_addToList(arg1,arg2){const arr1=asList(arg1,operationErrorText("_addToList",arg1,arg2)),arr2=asList(arg2,operationErrorText("_addToList",arg1,arg2));return arr1.concat(arr2.filter(guid=>!arr1.includes(guid)))},_removeFromList(arg1,arg2){const arr1=asList(arg1,operationErrorText("_removeFromList",arg1,arg2)),arr2=asList(arg2,operationErrorText("_removeFromList",arg1,arg2));return arr1.filter(guid=>!arr2.includes(guid))},_intersectLists(arg1,arg2){const arr1=asList(arg1,operationErrorText("_intersectLists",arg1,arg2)),arr2=asList(arg2,operationErrorText("_intersectLists",arg1,arg2));return arr1.filter(guid=>arr2.includes(guid))},_listContains(arg1,arg2){const arr1=asList(arg1,operationErrorText("_listContains",arg1,arg2)),arr2=asList(arg2,operationErrorText("_listContains",arg1,arg2));return arr2.length>0&&arr2.every(guid=>arr1.includes(guid))},_head(arg1){if(arg1 instanceof Array)return arg1.length>0?arg1[0]:void 0;if(void 0!==arg1)throw new Error(operationErrorText("_head",arg1))}};function asList(arg,errorText){if(arg instanceof Array)return arg;if(isString(arg))return arg.length>0?[arg]:[];if(void 0===arg)return[];throw new Error(errorText)}const expressionLogicFunctions={not:arg=>!arg,"=":(arg1,arg2)=>arg1 instanceof Big&&arg2 instanceof Big?arg1.eq(arg2):arg1 instanceof Date&&arg2 instanceof Date?arg1.getTime()===arg2.getTime():"string"==typeof arg1||"string"==typeof arg2?(arg1||"")===(arg2||""):arg1 instanceof Array&&arg2 instanceof Array?arg1.length===arg2.length&&arg1.every(elem=>arg2.includes(elem)):arg1 instanceof Array&&void 0===arg2?0===arg1.length:void 0===arg1&&arg2 instanceof Array?0===arg2.length:arg1===arg2,"!=":(arg1,arg2)=>!expressionLogicFunctions["="](arg1,arg2),">"(arg1,arg2){if(arg1 instanceof Big&&arg2 instanceof Big)return arg1.gt(arg2);if(arg1 instanceof Date&&arg2 instanceof Date)return arg1.getTime()>arg2.getTime();if(void 0===arg1||void 0===arg2)throw new Error(operationErrorText(">",arg1,arg2));return arg1>arg2},">=":(arg1,arg2)=>expressionLogicFunctions["="](arg1,arg2)||expressionLogicFunctions[">"](arg1,arg2),"<"(arg1,arg2){if(arg1 instanceof Big&&arg2 instanceof Big)return arg1.lt(arg2);if(arg1 instanceof Date&&arg2 instanceof Date)return arg1.getTime()<arg2.getTime();if(void 0===arg1||void 0===arg2)throw new Error(operationErrorText("<",arg1,arg2));return arg1<arg2},"<=":(arg1,arg2)=>expressionLogicFunctions["="](arg1,arg2)||expressionLogicFunctions["<"](arg1,arg2)},expressionMathFunctions={"+"(arg1,arg2){if(arg1 instanceof Big&&arg2 instanceof Big)return arg1.plus(arg2);if("string"==typeof arg1)return arg1+(void 0!==arg2?arg2.toString():"");if("string"==typeof arg2)return(void 0!==arg1?arg1.toString():"")+arg2;throw new Error(operationErrorText("+",arg1,arg2))},"-"(arg1,arg2){if(1===arguments.length&&void 0!==arg1)return arg1.times(-1);if(void 0!==arg1&&void 0!==arg2)return arg1.minus(arg2);throw new Error(operationErrorText("-",arg1,arg2))},"*"(arg1,arg2){if(void 0!==arg1&&void 0!==arg2)return arg1.times(arg2);throw new Error(operationErrorText("*",arg1,arg2))},div(arg1,arg2){if(void 0!==arg1&&void 0!==arg2)return arg1.div(arg2);throw new Error(operationErrorText("div",arg1,arg2))},mod(arg1,arg2){if(void 0!==arg1&&void 0!==arg2)return arg1.mod(arg2);throw new Error(operationErrorText("mod",arg1,arg2))},":":(arg1,arg2)=>expressionMathFunctions.div(arg1,arg2),max(...args){if(args[0]instanceof Big)return args.reduce((n1,n2)=>n1.gt(n2)?n1:n2);if(args[0]instanceof Date)return args.reduce((d1,d2)=>d1.getTime()>d2.getTime()?d1:d2);throw new Error(operationErrorText("max",...args))},min(...args){if(args[0]instanceof Big)return args.reduce((n1,n2)=>n1.lt(n2)?n1:n2);if(args[0]instanceof Date)return args.reduce((d1,d2)=>d1.getTime()<d2.getTime()?d1:d2);throw new Error(operationErrorText("min",...args))},round(arg,dp){if(arg instanceof Big)return arg.round(void 0===dp?0:Number(dp));throw new Error(operationErrorText("round",arg))},random:()=>new Big(Math.random()),floor(arg){if(arg instanceof Big){const fractional=arg.mod(1);return fractional.eq(0)?arg.eq(-0)?arg.abs():arg:arg.minus(fractional).minus(arg.lt(0)?1:0)}throw new Error(operationErrorText("floor",arg))},ceil(arg){if(arg instanceof Big){const result=expressionMathFunctions.floor(arg.times(-1));return result.eq(0)?result:result.times(-1)}throw new Error(operationErrorText("ceil",arg))},pow(arg,exponent){if(arg instanceof Big&&exponent instanceof Big)return arg.pow(Number(exponent));throw new Error(operationErrorText("pow",arg))},abs(arg){if(arg instanceof Big)return arg.abs();throw new Error(operationErrorText("abs",arg))}},expressionStringFunctions={toUpperCase:arg1=>asString(arg1).toUpperCase(),toLowerCase:arg1=>asString(arg1).toLowerCase(),trim:arg1=>asString(arg1).trim(),contains:(arg1,arg2)=>asString(arg1).includes(asString(arg2)),startsWith:(arg1,arg2)=>(arg1=asString(arg1),arg2=asString(arg2),arg1.substr(0,arg2.length)===arg2),endsWith:(arg1,arg2)=>(arg1=asString(arg1),arg2=asString(arg2),arg1.substr(arg1.length-arg2.length)===arg2),substring(arg1,arg2,arg3){if(arg1=asString(arg1),arg3=arg3,void 0!==(arg2=arg2)&&arg2.gte(0)){if(2===arguments.length)return arg1.substr(Number(arg2));if(void 0!==arg3&&arg3.gte(0))return arg1.substr(Number(arg2),Number(arg3))}throw new Error(operationErrorText("substring",arg1,arg2,arg3))},find(arg1,arg2,arg3){if(arg1=asString(arg1),arg2=asString(arg2),2===arguments.length)return new Big(arg1.indexOf(arg2));if(void 0!==arg3)return new Big(arg1.indexOf(arg2,Number(arg3)));throw new Error(operationErrorText("find",arg1,arg2,arg3))},findLast(arg1,arg2,arg3){if(arg1=asString(arg1),arg2=asString(arg2),2===arguments.length)return new Big(arg1.lastIndexOf(arg2));if(void 0!==arg3)return new Big(arg1.lastIndexOf(arg2,Number(arg3)));throw new Error(operationErrorText("findLast",arg1,arg2,arg3))},length:arg1=>new Big(asString(arg1).length),urlEncode:arg1=>encodeURIComponent(asString(arg1)).replace("%20","+"),urlDecode:arg1=>decodeURIComponent(asString(arg1).replace("+","%20")),isMatch(arg1,arg2){if(void 0!==arg2)return new RegExp(`^(${arg2})$`).test(asString(arg1));throw new Error(operationErrorText("isMatch",arg1,arg2))},replaceFirst(arg1,arg2,arg3){if(void 0!==arg2&&void 0!==arg3){const escapedForReplaceValue=arg3.replace(/\$/g,"$$$$");return asString(arg1).replace(new RegExp(arg2),escapedForReplaceValue)}throw new Error(operationErrorText("replaceFirst",arg1,arg2))},replaceAll(arg1,arg2,arg3){if(void 0!==arg2&&void 0!==arg3){const escapedForReplaceValue=arg3.replace(/\$/g,"$$$$");return asString(arg1).replace(new RegExp(arg2,"g"),escapedForReplaceValue)}throw new Error(operationErrorText("replaceAll",arg1,arg2))}};function asString(arg){return void 0===arg?"":arg}const expressionFunctions=Object.assign({},expressionDateFunctions,expressionListFunctions,expressionLogicFunctions,expressionMathFunctions,expressionStringFunctions,{toString:arg1=>arg1 instanceof Big?arg1.toString():void 0===arg1?"":arg1 instanceof Date?mx.parser.formatValue(arg1.getTime(),"DateTime",{type:"datetime"}):String(arg1),parseInteger(arg,defaultValue){if("string"==typeof arg){if(/^-?\d+$/.test(arg)){const result=Big(arg);return result.eq(-0)?result.abs():result}if(void 0===defaultValue)throw new Error(`Not parsable to Integer: ${arg}`);return defaultValue}throw new Error(operationErrorText("parseInteger",arg))},parseDecimal(arg,defaultValue){if("string"==typeof arg){const parsed=mx.parser.parseValue(arg,"Decimal");if(null===parsed&&void 0===defaultValue)throw new Error(`Not parsable to Decimal: ${arg}`);return null===parsed?defaultValue:parsed}throw new Error(operationErrorText("parseDecimal",arg))},formatDecimal(arg){if(arg instanceof Big)return mx.parser.formatValue(Number(arg),"Decimal");throw new Error(operationErrorText("formatDecimal",arg))},isNew:arg1=>void 0!==arg1&&mx.data.isNew(arg1),isSynced(arg1){if(void 0!==arg1)return!mx.data.isDirty(arg1);throw new Error(operationErrorText("isSynced",arg1))},_hasSomeRole:(...args)=>mx.session.hasSomeRole(args)});var isArray=Array.isArray,keyList=Object.keys,hasProp=Object.prototype.hasOwnProperty,fastDeepEqual=function equal(a,b){if(a===b)return!0;if(a&&b&&"object"==typeof a&&"object"==typeof b){var i,length,key,arrA=isArray(a),arrB=isArray(b);if(arrA&&arrB){if((length=a.length)!=b.length)return!1;for(i=length;0!=i--;)if(!equal(a[i],b[i]))return!1;return!0}if(arrA!=arrB)return!1;var dateA=a instanceof Date,dateB=b instanceof Date;if(dateA!=dateB)return!1;if(dateA&&dateB)return a.getTime()==b.getTime();var regexpA=a instanceof RegExp,regexpB=b instanceof RegExp;if(regexpA!=regexpB)return!1;if(regexpA&&regexpB)return a.toString()==b.toString();var keys=keyList(a);if((length=keys.length)!==keyList(b).length)return!1;for(i=length;0!=i--;)if(!hasProp.call(b,keys[i]))return!1;for(i=length;0!=i--;)if(!equal(a[key=keys[i]],b[key]))return!1;return!0}return a!=a&&b!=b};class AccessDeniedError extends Error{constructor(variableName,entityName,attributeName){super(`Unable to get a member from variable $${variableName}, because you do not have sufficient permissions to "${entityName}.${attributeName}".`),this.variableName=variableName,this.entityName=entityName,this.attributeName=attributeName,Object.setPrototypeOf(this,AccessDeniedError.prototype)}}class EmptyVariableAccessError extends Error{constructor(variableName){super(`Unable to get a member from an empty variable $${variableName}.`),this.variableName=variableName,Object.setPrototypeOf(this,EmptyVariableAccessError.prototype)}}class Resolver{constructor(variables){this.variables=variables,this.dependencies=[]}resolve(variable,path){return void 0!==path?this.resolveAttribute(variable,path):this.resolveVariable(variable)}getDependencies(){return this.dependencies.slice()}resolveVariable(name){if(!(name in this.variables))throw new AssertionError;const value=this.variables[name]();if(value instanceof MxObject)return this.addDependency({guid:value.getGuid()}),value.getGuid();if(isArrayOf(MxObject,value)){const guids=value.map(obj=>obj.getGuid());return guids.forEach(guid=>this.addDependency({guid:guid})),guids}return value}resolveAttribute(variable,attribute){if(!(variable in this.variables))throw new AssertionError;const obj=this.variables[variable]();if(void 0===obj)throw new EmptyVariableAccessError(variable);if(!(obj instanceof MxObject))throw new AssertionError;if(!obj.has(attribute))throw new AccessDeniedError(variable,obj.getEntity(),attribute);return this.addDependency({guid:obj.getGuid()}),this.addDependency({guid:obj.getGuid(),attr:attribute}),clientToAttributeValue(obj.get(attribute),obj.getAttributeType(attribute))}addDependency(dependency){this.dependencies.find(dep=>fastDeepEqual(dep,dependency))||this.dependencies.push(dependency)}}const funcMap={beginOfCurrentMinute:startOfMinute,endOfCurrentMinute:endOfMinute,beginOfCurrentHour:startOfHour,endOfCurrentHour:endOfHour,beginOfCurrentDay:startOfDay,endOfCurrentDay:endOfDay,beginOfCurrentWeek:startOfWeek,endOfCurrentWeek:endOfWeek,beginOfCurrentMonth:startOfMonth,endOfCurrentMonth:endOfMonth,beginOfCurrentYear:startOfYear,endOfCurrentYear:endOfYear};function createExpressionTokens(getNow){const tokensCollection={currentUser:()=>mx.session.getUserId(),currentDateTime:getNow};return Object.keys(funcMap).forEach(exposedName=>{const func=funcMap[exposedName];tokensCollection[exposedName]=()=>func(getNow(),{weekStartsOn:mx.session.getConfig("locale.firstDayOfWeek")}),tokensCollection[exposedName+"UTC"]=()=>delocalizeDate(func(localizeDate(getNow())))}),tokensCollection}export{AccessDeniedError as A,Evaluator as E,Resolver as R,EmptyVariableAccessError as a,createExpressionTokens as c,expressionFunctions as e,toDateFnsPattern as t};
