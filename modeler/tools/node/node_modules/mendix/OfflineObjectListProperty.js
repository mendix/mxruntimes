import{f as computed,o as observable,r as reaction,e as comparer}from"./ef69c932.js";import"./53bf75a6.js";import"./567083d6.js";import{a as asProperty}from"./e3b801f3.js";import{B as Big}from"./2bc24ff8.js";import"./ceec5c0e.js";import"./36940eec.js";import"./fdd4c4ff.js";import"./84420dbd.js";import"./573c00fc.js";import{v as valueMonitor,b as using,h as asDynamicValue,a as available,m as mapL,l as loading,d as loadableResource}from"./fa8bd0aa.js";import{M as MxObject1}from"./4cb96a65.js";import{t as toObjectItem}from"./7975ceb4.js";import{o as objectListTrigger,a as getApplyContextCount$,w as withPageInfoSharing,b as getCurrentPage$}from"./1a828ffa.js";const OfflineObjectListProperty=asProperty((config,store,widgetId)=>{const fetchTrigger=objectListTrigger(config,store,()=>{if(void 0===config.reference)return available(void 0);const rootObject=MxObject1.fromState$(store.get$(config.scope,"object"));return mapL(rootObject,mxobj=>({attribute:config.reference,operator:"equals",value:mxobj.getGuid()}))}),applyContextMonitor=valueMonitor(()=>getApplyContextCount$(store)),pageValue=computed(()=>(applyContextMonitor.runIfChanged(applyContextCount=>{void 0!==applyContextCount&&applyContextCount>0&&store.set(widgetId,"offset",Big(0))}),getCurrentPage$(config,store,widgetId)));let ignorePageChange=!1;const resourceBox=observable.box(computed(()=>loading()),{deep:!1}),fetchResult=using(()=>[reaction(()=>({trigger:fetchTrigger.get(),page:pageValue.get()}),({trigger:trigger,page:page})=>{if(ignorePageChange)return void(ignorePageChange=!1);if(!trigger.load)return;const referenceConstraint=trigger.parameters;if("available"!==referenceConstraint.status)return void resourceBox.set(computed(()=>loading()));const currentList=resourceBox.get().get(),{sliceToKeep:sliceToKeep,pageToFetch:pageToFetch,loadAtEnd:loadAtEnd}=function(currentList,page){if("available"!==currentList.status)return{};const[currentStart,currentEnd]=[currentList.value.offset,currentList.value.offset+currentList.value.items.length],[newStart,newEnd]=[page.offset,page.offset+page.amount],[keepStart,keepEnd]=[Math.max(currentStart,newStart),Math.min(currentEnd,newEnd)];if(keepStart>=keepEnd)return{};if(newStart<keepStart&&newEnd>keepEnd)return{};const loadAtEnd=newEnd>currentEnd,pageToFetch={offset:loadAtEnd?keepEnd:newStart,amount:newEnd-newStart-(keepEnd-keepStart)};return{sliceToKeep:[keepStart-currentStart,keepEnd-currentStart],loadAtEnd:loadAtEnd,pageToFetch:pageToFetch.amount>0?pageToFetch:void 0}}(currentList,page);if("available"!==currentList.status||currentList.value.version!==trigger.version||void 0===sliceToKeep)resourceBox.set(loadableResource(`Load data for ${config.friendlyId}`,()=>fetch(page,trigger.version,referenceConstraint.value).then(listInfo=>retryOnEmptyResult(listInfo,referenceConstraint.value))));else if(void 0===pageToFetch){const newList=Object.assign({},currentList.value,{offset:page.offset,items:currentList.value.items.slice(...sliceToKeep)});resourceBox.set(computed(()=>available(newList)))}else resourceBox.set(loadableResource(`Extend page for ${config.friendlyId}`,async()=>{const reusedItems=currentList.value.items.slice(...sliceToKeep),extraList=await fetch(pageToFetch,currentList.value.version,referenceConstraint.value);return retryOnEmptyResult(Object.assign({},currentList.value,{offset:page.offset,items:loadAtEnd?reusedItems.concat(extraList.items):extraList.items.concat(reusedItems),hasMoreItems:loadAtEnd?extraList.hasMoreItems:currentList.value.hasMoreItems}),referenceConstraint.value)},currentList))},{fireImmediately:!0,equals:comparer.structural})],()=>resourceBox.get().get()),listInfo=withPageInfoSharing(()=>fetchResult.get(),store,widgetId),result=asDynamicValue(()=>listInfo.get());return()=>result.get();async function fetch({offset:offset,amount:amount},version,rootObjectConstraint){const filter=Object.assign({offset:offset},amount!==Number.POSITIVE_INFINITY?{limit:amount}:{},config.sort?{sort:config.sort}:{}),constraints=void 0===rootObjectConstraint?config.constraints:[...config.constraints,rootObjectConstraint];return new Promise((resolve,reject)=>mx.data.getSlice(config.entity,constraints,filter,!0,(mxobjs,count)=>resolve({items:mxobjs.map(o=>toObjectItem(o,widgetId)),totalCount:count,hasMoreItems:offset+amount<count,offset:offset,version:version}),reject))}function retryOnEmptyResult(listInfo,rootObjectConstraint){return 0===listInfo.items.length&&listInfo.offset>0?(ignorePageChange=!0,store.set(widgetId,"offset",Big(0)),fetch(pageValue.get(),listInfo.version,rootObjectConstraint).then(available)):available(listInfo)}});export{OfflineObjectListProperty};
