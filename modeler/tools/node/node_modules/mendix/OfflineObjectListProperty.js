import{d as computed,o as observable,r as reaction,g as comparer}from"./f0d16cff.js";import"./ad1d08ab.js";import{z as valueMonitor,o as using,y as asDynamicValue,a as available,d as mapL,l as loading,q as loadableResource}from"./79cc6120.js";import{a as asProperty}from"./72a4665b.js";import{Big}from"big.js";import"./50adac5e.js";import"./6ae611dc.js";import"./b98156b5.js";import"./0e7164f2.js";import{M as MxObject1}from"./b4a5c3fe.js";import{t as toObjectItem}from"./2d0c3e4e.js";import{o as objectListTrigger,w as withPageInfoSharing,a as getApplyContextCount$,b as getCurrentPage$}from"./0d49412d.js";const OfflineObjectListProperty=asProperty((config,store,widgetId)=>{const fetchTrigger=objectListTrigger(config,store,()=>{if(void 0===config.reference)return available(void 0);const rootObject=MxObject1.fromState$(store.get$(config.scope,"object"));return mapL(rootObject,mxobj=>({attribute:config.reference,operator:"equals",value:mxobj.getGuid()}))}),applyContextMonitor=valueMonitor(()=>getApplyContextCount$(store)),pageValue=computed(()=>(applyContextMonitor.runIfChanged(applyContextCount=>{void 0!==applyContextCount&&applyContextCount>0&&store.set(widgetId,"offset",Big(0))}),getCurrentPage$(config,store,widgetId)));let ignorePageChange=!1;const resourceBox=observable.box(computed(()=>loading()),{deep:!1}),fetchResult=using(()=>[reaction(()=>({trigger:fetchTrigger.get(),page:pageValue.get()}),({trigger:trigger,page:page})=>{if(ignorePageChange)return void(ignorePageChange=!1);if(!trigger.load)return;const referenceConstraint=trigger.parameters;if("available"!==referenceConstraint.status)return void resourceBox.set(computed(()=>loading()));const currentList=resourceBox.get().get(),{sliceToKeep:sliceToKeep,pageToFetch:pageToFetch,loadAtEnd:loadAtEnd}=function(currentList,page){if("available"!==currentList.status)return{};const[currentStart,currentEnd]=[currentList.value.offset,currentList.value.offset+currentList.value.items.length],[newStart,newEnd]=[page.offset,page.offset+page.amount],[keepStart,keepEnd]=[Math.max(currentStart,newStart),Math.min(currentEnd,newEnd)];if(keepStart>=keepEnd)return{};if(newStart<keepStart&&newEnd>keepEnd)return{};const loadAtEnd=newEnd>currentEnd,pageToFetch={offset:loadAtEnd?keepEnd:newStart,amount:newEnd-newStart-(keepEnd-keepStart)};return{sliceToKeep:[keepStart-currentStart,keepEnd-currentStart],loadAtEnd:loadAtEnd,pageToFetch:pageToFetch.amount>0?pageToFetch:void 0}}(currentList,page);if("available"!==currentList.status||currentList.value.version!==trigger.version||void 0===sliceToKeep)resourceBox.set(loadableResource(`Load data for ${config.friendlyId}`,()=>fetch(page,trigger.version,referenceConstraint.value).then(listInfo=>retryOnEmptyResult(listInfo,referenceConstraint.value))));else if(void 0===pageToFetch){const newList=Object.assign(Object.assign({},currentList.value),{offset:page.offset,items:currentList.value.items.slice(...sliceToKeep)});resourceBox.set(computed(()=>available(newList)))}else resourceBox.set(loadableResource(`Extend page for ${config.friendlyId}`,async()=>{const reusedItems=currentList.value.items.slice(...sliceToKeep),extraList=await fetch(pageToFetch,currentList.value.version,referenceConstraint.value);return retryOnEmptyResult(Object.assign(Object.assign({},currentList.value),{offset:page.offset,items:loadAtEnd?reusedItems.concat(extraList.items):extraList.items.concat(reusedItems),hasMoreItems:loadAtEnd?extraList.hasMoreItems:currentList.value.hasMoreItems}),referenceConstraint.value)},currentList))},{fireImmediately:!0,equals:comparer.structural})],()=>resourceBox.get().get()),listInfo=withPageInfoSharing(()=>fetchResult.get(),store,widgetId),result=asDynamicValue(()=>listInfo.get());return()=>result.get();async function fetch({offset:offset,amount:amount},version,rootObjectConstraint){const filter=Object.assign(Object.assign({offset:offset},amount!==Number.POSITIVE_INFINITY?{limit:amount}:{}),config.sort?{sort:config.sort}:{}),constraints=void 0===rootObjectConstraint?config.constraints:[...config.constraints,rootObjectConstraint];return new Promise((resolve,reject)=>mx.data.getSlice(config.entity,constraints,filter,!0,(mxobjs,count)=>resolve({items:mxobjs.map(o=>toObjectItem(o,widgetId)),totalCount:count,hasMoreItems:offset+amount<count,offset:offset,version:version}),reject))}function retryOnEmptyResult(listInfo,rootObjectConstraint){return 0===listInfo.items.length&&listInfo.offset>0?(ignorePageChange=!0,store.set(widgetId,"offset",Big(0)),fetch(pageValue.get(),listInfo.version,rootObjectConstraint).then(available)):available(listInfo)}});export{OfflineObjectListProperty};
