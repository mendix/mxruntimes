import"./d5eebceb.js";import{h as computed$$1,f as observable$$1,a as reaction$$1,e as comparer$$1}from"./6727fec8.js";import"./eed44530.js";import"./aa3ddc5d.js";import"./ff203afa.js";import"./02d97a6c.js";import{c as asProperty}from"./71d615f7.js";import{a as Big}from"./3019ed1f.js";import"./967e2ac0.js";import"./b3fab43d.js";import{d as available,e as mapL,a as loading}from"./7a470c91.js";import{d as valueMonitor,c as using,b as loadableResource}from"./12049987.js";import{b as MxObject1}from"./8a992959.js";import{a as toObjectItem}from"./4068f775.js";import{b as objectListTrigger,c as getApplyContextCount,d as getCurrentPage,e as withPageInfoSharing}from"./6fa8a362.js";const OfflineObjectListProperty=asProperty((config,store,widgetId)=>{const fetchTrigger=objectListTrigger(config,store,()=>{if(void 0===config.reference)return available(void 0);const rootObject=MxObject1.fromState(store.get(config.scope,"object"));return mapL(rootObject,mxobj=>({attribute:config.reference,operator:"equals",value:mxobj.getGuid()}))}),applyContextMonitor=valueMonitor(()=>getApplyContextCount(store)),pageValue=computed$$1(()=>(applyContextMonitor.runIfChanged(applyContextCount=>{void 0!==applyContextCount&&applyContextCount>0&&store.set(widgetId,"offset",Big(0))}),getCurrentPage(config,store,widgetId)));let ignorePageChange=!1;const resourceBox=observable$$1.box(computed$$1(()=>loading()),{deep:!1}),fetchResult=using(()=>[reaction$$1(()=>({trigger:fetchTrigger.get(),page:pageValue.get()}),({trigger:trigger,page:page})=>{if(ignorePageChange)return void(ignorePageChange=!1);if(!trigger.load)return;const referenceConstraint=trigger.parameters;if("available"!==referenceConstraint.status)return void resourceBox.set(computed$$1(()=>loading()));const currentList=resourceBox.get().get(),{sliceToKeep:sliceToKeep,pageToFetch:pageToFetch,loadAtEnd:loadAtEnd}=function(currentList,page){if("available"!==currentList.status)return{};const[currentStart,currentEnd]=[currentList.value.offset,currentList.value.offset+currentList.value.items.length],[newStart,newEnd]=[page.offset,page.offset+page.amount],[keepStart,keepEnd]=[Math.max(currentStart,newStart),Math.min(currentEnd,newEnd)];if(keepStart>=keepEnd)return{};if(newStart<keepStart&&newEnd>keepEnd)return{};const loadAtEnd=newEnd>currentEnd,pageToFetch={offset:loadAtEnd?keepEnd:newStart,amount:newEnd-newStart-(keepEnd-keepStart)};return{sliceToKeep:[keepStart-currentStart,keepEnd-currentStart],loadAtEnd:loadAtEnd,pageToFetch:pageToFetch.amount>0?pageToFetch:void 0}}(currentList,page);if("available"!==currentList.status||currentList.value.version!==trigger.version||void 0===sliceToKeep)resourceBox.set(loadableResource(`Load data for ${config.friendlyId}`,()=>fetch(page,trigger.version,referenceConstraint.value).then(listInfo=>retryOnEmptyResult(listInfo,referenceConstraint.value))));else if(void 0===pageToFetch){const newList=Object.assign({},currentList.value,{offset:page.offset,items:currentList.value.items.slice(...sliceToKeep)});resourceBox.set(computed$$1(()=>available(newList)))}else resourceBox.set(loadableResource(`Extend page for ${config.friendlyId}`,async()=>{const reusedItems=currentList.value.items.slice(...sliceToKeep),extraList=await fetch(pageToFetch,currentList.value.version,referenceConstraint.value);return retryOnEmptyResult(Object.assign({},currentList.value,{offset:page.offset,items:loadAtEnd?reusedItems.concat(extraList.items):extraList.items.concat(reusedItems),hasMoreItems:loadAtEnd?extraList.hasMoreItems:currentList.value.hasMoreItems}),referenceConstraint.value)},currentList))},{fireImmediately:!0,equals:comparer$$1.structural})],()=>resourceBox.get().get()),result=withPageInfoSharing(()=>fetchResult.get(),store,widgetId);return()=>result.get();function fetch({offset:offset,amount:amount},version,rootObjectConstraint){const filter=Object.assign({offset:offset},amount!==Number.POSITIVE_INFINITY?{limit:amount}:{},config.sort?{sort:config.sort}:{}),constraints=void 0===rootObjectConstraint?config.constraints:[...config.constraints,rootObjectConstraint];return new Promise((resolve,reject)=>mx.data.getSlice(config.entity,constraints,filter,!0,(mxobjs,count)=>resolve({items:mxobjs.map(o=>toObjectItem(o,widgetId)),totalCount:count,hasMoreItems:offset+amount<count,offset:offset,version:version}),reject))}function retryOnEmptyResult(listInfo,rootObjectConstraint){return 0===listInfo.items.length&&listInfo.offset>0?(ignorePageChange=!0,store.set(widgetId,"offset",Big(0)),fetch(pageValue.get(),listInfo.version,rootObjectConstraint).then(available)):available(listInfo)}});export{OfflineObjectListProperty};
