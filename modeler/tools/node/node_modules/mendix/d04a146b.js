import{b as computed}from"./14498da2.js";import{A as AssertionError}from"./53bf75a6.js";import{f as fromLoadable}from"./573c00fc.js";function ensure(arg){if(null==arg)throw new Error("Did not expect an argument to be undefined");return arg}function crash(){throw new AssertionError}function friendlyName(Component){return Component.displayName||Component.name||"<component>"}function isString(value){return"string"==typeof value}function isJson(obj){return null!=obj&&"object"==typeof obj&&obj.constructor==={}.constructor}function isArrayOf(type,value){return value instanceof Array&&value.every(v=>void 0===v||v instanceof type)}function splitAttributePath(attributePath){const parts=attributePath.split("/");return parts.length>1&&parts.shift(),{attribute:parts.pop(),entityPath:parts.length?parts.join("/"):void 0}}function unique(list){return Array.from(new Set(list))}function tuple(...args){return args}function mapValues(source,mapValue){const result={};return Object.keys(source).forEach(key=>result[key]=mapValue(source[key])),result}function uniqueBy(list,keySelector){const res=[],keys={};return list.forEach(item=>{const key=keySelector(item);Object.prototype.hasOwnProperty.call(keys,key)||(keys[key]=!0,res.push(item))}),res}function concat(arrays){return[].concat(...arrays)}function escapeXml(s){return s.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&apos;")}function containsKey(key,obj){return Object.prototype.hasOwnProperty.call(obj,key)}const LOADING={status:"loading"};function loading(){return LOADING}const UNAVAILABLE={status:"unavailable"};function unavailable(){return UNAVAILABLE}function available(value){return{status:"available",value:value}}function getOrElseL(value,def){return"available"===value.status?value.value:def}function getOrCrashL(value){return"available"===value.status?value.value:crash()}function liftL(action){return loadable=>mapL(loadable,action)}function mapL(loadable,action){return flatMapL(loadable,v=>available(action(v)))}function flatMapL(loadable,action){return"available"===loadable.status?action(loadable.value):loadable}function flattenArrayL(array){return array.reduce((acc,el)=>acc.concat("available"===el.status?[el.value]:[]),[])}function asDynamicValue(func$){return asReloadable(()=>fromLoadable(func$()),v=>({value:v.value}))}function asReloadable(func$,rememberFunc){let lastSeenValue;return computed(()=>{const value=func$();switch(value.status){case"loading":return Object.assign({},value,lastSeenValue);case"unavailable":return lastSeenValue={},value;case"available":return lastSeenValue=rememberFunc(value),value}})}export{available as a,uniqueBy as b,concat as c,mapL as d,ensure as e,friendlyName as f,getOrElseL as g,crash as h,isJson as i,escapeXml as j,unavailable as k,loading as l,mapValues as m,flatMapL as n,flattenArrayL as o,isString as p,isArrayOf as q,containsKey as r,getOrCrashL as s,splitAttributePath as t,unique as u,asDynamicValue as v,asReloadable as w,tuple as x,liftL as y};
