import{A as AssertionError}from"./43297fe2.js";import{g as escapeXml}from"./c49f953c.js";import{s as subscribe}from"./ee5a929f.js";import{Big}from"big.js";import{M as MxObject,i as clientToAttributeValue,j as anyToExpressionVariable,k as attributeToClientValue,l as expressionVariableToRuntimeValue}from"./d6b7d05a.js";import{b as getJavaScriptAction,c as getNanoflow}from"./49a60b8f.js";import{e as expressionFunctions,c as createExpressionTokens,a as evaluateFlowExpression}from"./7ca6d1ae.js";async function never(){return new Promise(()=>{})}async function wait(timeout=0){return new Promise(resolve=>{setTimeout(()=>{resolve()},timeout)})}async function methodToPromise(subject,functionName,...args){return new Promise((resolve,reject)=>subject[functionName](...args,resolve,reject))}class ObjectValidation{constructor(guid,fields){this._guid=guid,this._fields=fields}getGuid(){return this._guid}getAttributes(){return Object.keys(this._fields).map(name=>({name:name,reason:this._fields[name]}))}getFields(){return this.getAttributes()}static describe(validations){const list=[];for(let i=0;void 0!==validations[i];i++){const fields=validations[i].getFields();for(let x=0;void 0!==fields[x];x++)list.push(fields[x].reason)}return list.join("\n")}addAttribute(attr,message){return!(attr in this._fields)&&(this._fields[attr]=message,!0)}addField(...args){return this.addAttribute(...args)}removeAttribute(attr){return attr in this._fields&&(delete this._fields[attr],!0)}removeField(...args){return this.removeAttribute(...args)}getErrorReason(attr){return this._fields[attr]}getReasonByAttribute(...args){return this.getErrorReason(...args)}clone(){return new ObjectValidation(this._guid,Object.assign({},this._fields))}toString(){return Object.keys(this._fields).map(attr=>`${attr} ${this._fields[attr]}`).join("; ")}}ObjectValidation.fromResponse=function(datavalidation){return datavalidation.map(({guid:guid,errorFields:errorFields})=>{const fieldMap={};return errorFields.forEach(({name:name,message:message})=>{fieldMap[name]=message}),new ObjectValidation(guid,fieldMap)})};const LATEST_ERROR="latestError";class FlowScope{constructor(currentForm){this.currentForm=currentForm,this.map={},this.subscriptions=[],this.map[LATEST_ERROR]=void 0}set(name,value){this.map[name]=value,value instanceof MxObject?this.subscriptions.push(subscribe({guid:value.getGuid()})):Array.isArray(value)&&this.subscriptions.push(...value.map(obj=>subscribe({guid:obj.getGuid()})))}get(name){if(!(name in this.map))throw new AssertionError;const value=this.map[name];return value instanceof MxObject&&value.isUnavailable()?void 0:Array.isArray(value)?value.filter(v=>!v.isUnavailable()):value}all(){return Object.keys(this.map)}mapGuidsToObjects(guids){const guidToObj={};return this.all().map(vn=>this.get(vn)).map(value=>value instanceof MxObject?[value]:Array.isArray(value)?value:[]).reduce((a,b)=>a.concat(b),[]).forEach(mxobj=>{guidToObj[mxobj.getGuid()]=mxobj}),guids.filter(guid=>guid in guidToObj).map(guid=>guidToObj[guid])}destroy(){this.subscriptions.forEach(s=>s.unsubscribe()),this.subscriptions.splice(0)}}function isReturn(value){return void 0!==value&&"object"==typeof value&&"result"in value}class NanoflowCallExecutor{constructor(evaluateExpression,executeNanoflow){this.evaluateExpression=evaluateExpression,this.executeNanoflow=executeNanoflow,this.instructionType="nanoflowCall"}async execute({flow:flow,parameters:parameters,outputVar:outputVar},scope){const args=parameters.map(parameter=>({name:parameter.name,value:this.evaluateExpression(parameter.value,scope,parameter.kind)})),result=await this.executeNanoflow(flow,args,scope.currentForm);void 0!==outputVar&&scope.set(outputVar,result)}}var AggregateFunction;!function(AggregateFunction){AggregateFunction.Sum="Sum",AggregateFunction.Average="Average",AggregateFunction.Count="Count",AggregateFunction.Minimum="Minimum",AggregateFunction.Maximum="Maximum"}(AggregateFunction||(AggregateFunction={}));class AggregateExecutor{constructor(){this.instructionType="aggregate"}async execute(instruction,scope){const inputList=scope.get(instruction.inputVar);Array.isArray(inputList)&&(instruction.operation===AggregateFunction.Count?scope.set(instruction.outputVar,new Big(inputList.length)):scope.set(instruction.outputVar,function(inputList,operation,member){const inputValues=inputList.map(obj=>obj.get(member)).filter(val=>val instanceof Big);switch(operation){case AggregateFunction.Minimum:return 0===inputValues.length?void 0:inputValues.reduce((curMin,curVal)=>curVal.lt(curMin)?curVal:curMin,inputValues[0]);case AggregateFunction.Maximum:return 0===inputValues.length?void 0:inputValues.reduce((curMax,curVal)=>curVal.gt(curMax)?curVal:curMax,inputValues[0]);case AggregateFunction.Average:return 0===inputValues.length?void 0:sum(inputValues).div(inputValues.length);case AggregateFunction.Sum:return sum(inputValues)}return}(inputList,instruction.operation,instruction.member)))}}function sum(values){return values.reduce((sum,curValue)=>sum.plus(curValue),new Big(0))}class FilterListExecutor{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="filterList"}async execute(instruction,scope){const input=scope.get(instruction.inputVar),expected=this.evaluateExp(instruction.expectedValue,scope,"primitive"),result=Array.isArray(input)?input.filter((function(obj){const value=obj.get(instruction.attribute),type=obj.getAttributeType(instruction.attribute);return expressionFunctions["="](clientToAttributeValue(value,type),expected)})):[];scope.set(instruction.outputVar,instruction.retrieveSingleObject?result.length>0?result[0]:void 0:result)}}class JavaScriptActionExecutor{constructor(evaluateExp,executeNanoflow){this.evaluateExp=evaluateExp,this.executeNanoflow=executeNanoflow,this.instructionType="javaScriptActionCall"}async execute(instruction,scope){const resolvedParameters=instruction.parameters.map(param=>"nanoflowId"===param.kind?this.createNanoflowWrapper(param.value,scope):this.evaluateExp(param.value,scope,param.kind)),action=await getJavaScriptAction(instruction.action),result=await action(...resolvedParameters);instruction.outputVar&&scope.set(instruction.outputVar,anyToExpressionVariable(result))}createNanoflowWrapper(nanoflowId,scope){if(void 0!==nanoflowId)return(args={})=>{const flatArgs=Object.keys(args).map(name=>({name:name,value:anyToExpressionVariable(args[name])}));return this.executeNanoflow(nanoflowId,flatArgs,scope.currentForm)}}}class JumpExecutor{constructor(){this.instructionType="jump"}async execute(instruction,_scope){return{goto:instruction.target}}}class LoopExecutor{constructor(executeInstructions){this.executeInstructions=executeInstructions,this.instructionType="loop"}async execute(instruction,scope){const list=scope.get(instruction.listVar);if(!Array.isArray(list))throw new AssertionError;for(const obj of list)if(scope.set(instruction.iteratorVar,obj),await this.executeInstructions(instruction.body,scope))break}}class AssociationRetrieveExecutor{constructor(){this.instructionType="associationRetrieve"}async execute(instruction,scope){const{inputVar:inputVar,association:association,entity:entity,retrieveSingleObject:retrieveSingleObject,direction:direction,outputVar:outputVar}=instruction,obj=scope.get(inputVar);if(void 0===obj)return void scope.set(outputVar,retrieveSingleObject?void 0:[]);if(!(obj instanceof MxObject))throw new AssertionError;const mxobjs=await async function(mxobj,path,entity,direction){return new Promise((resolve,reject)=>{mx.data.get({guid:mxobj.getGuid(),path:path,entity:entity,direction:direction,callback:resolve,error:reject})})}(obj,association,entity,direction);scope.set(outputVar,retrieveSingleObject?mxobjs[0]:mxobjs)}}class NanoflowError extends Error{constructor(message){super(message),Object.setPrototypeOf(this,NanoflowError.prototype)}}class ChangeObjectExecutor{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="changeObject"}async execute(instruction,scope){const obj=scope.get(instruction.inputVar);if(void 0===obj)throw new NanoflowError(`Cannot change $${instruction.inputVar} as it is empty`);if(!(obj instanceof MxObject))throw new AssertionError;const exprValue=this.evaluateExp(instruction.value,scope,"primitive");let clientValue=attributeToClientValue(exprValue);clientValue instanceof Big&&(clientValue=clientValue.round(8)),obj.set(instruction.member,clientValue)}}class CommitObjectsExecutor{constructor(){this.instructionType="commitObjects"}async execute(instruction,scope){const variable=scope.get(instruction.inputVar);if(variable instanceof MxObject)await commit([variable]);else{if(!Array.isArray(variable))throw void 0===variable?new NanoflowError(`Cannot commit $${instruction.inputVar} as it is empty`):new AssertionError;await commit(variable)}}}async function commit(mxobjs){return new Promise((resolve,reject)=>mx.data.commit({mxobjs:mxobjs,callback:resolve,error:reject}))}class CreateObjectExecutor{constructor(){this.instructionType="createObject"}async execute(instruction,scope){const obj=await new Promise((resolve,reject)=>mx.data.create({entity:instruction.objectType,callback:resolve,error:reject}));scope.set(instruction.outputVar,obj)}}const expressionTokens=createExpressionTokens(()=>new Date);function toQueryFilterValue(source,attribute){if(null!=source){if("string"==typeof source||"boolean"==typeof source||source instanceof Date||source instanceof Big)return source;if("number"==typeof source)return Big(source);if(source instanceof MxObject){if(void 0!==attribute){return clientToAttributeValue(source.get(attribute),source.getAttributeType(attribute))}return source.getGuid()}throw new AssertionError(`Cannot use value '${source}' in query filter`)}}function toXpathConstraint(filter){switch(filter.type){case"attribute":return filter.attribute;case"value":const value=filter.value;if(void 0===value)return"empty";if("string"==typeof value)return`'${escapeXml(value)}'`;if("boolean"==typeof value)return value?"true()":"false()";if(value instanceof Big)return value.toString();if(value instanceof Date)return value.getTime().toString();throw new AssertionError;case"function":return/^(\W+|and|or)$/.test(filter.name)?"("+filter.parameters.map(toXpathConstraint).join(` ${filter.name} `)+")":`${filter.name}(`+filter.parameters.map(toXpathConstraint).join(", ")+")"}}class DatabaseRetrieveExecutor{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="databaseRetrieve"}async execute(instruction,scope){const{entity:entity,constraints:constraints,limitExpr:limitExpr,offsetExpr:offsetExpr,takeFirst:takeFirst,sort:sort,outputVar:outputVar}=instruction,limit=limitExpr?this.evaluateExp(limitExpr,scope,"primitive"):void 0,offset=offsetExpr?this.evaluateExp(offsetExpr,scope,"primitive"):void 0,filter=constraints?function toQueryFilter(constraint,scope){switch(constraint.type){case"attribute":return constraint;case"function":return{type:"function",name:constraint.name,parameters:constraint.parameters.map(p=>toQueryFilter(p,scope))};case"literal":return{type:"value",value:toQueryFilterValue(constraint.value)};case"token":return{type:"value",value:expressionTokens[constraint.name]()};case"variable":return{type:"value",value:toQueryFilterValue(scope.get(constraint.name),constraint.attribute)}}}(constraints,scope):void 0,options=Object.assign(Object.assign(Object.assign({},offset?{offset:Number(offset)}:{}),limit?{amount:Number(limit)}:{}),sort?{sort:sort}:{}),{mxobjs:mxobjs}=mx.isOffline()?await mx.offlineData.retrieve(entity,filter,options):await mx.onlineData.retrieveByXPathNoSchema(`//${entity}`+(filter?`[${toXpathConstraint(filter)}]`:""),options);scope.set(outputVar,takeFirst?mxobjs[0]:mxobjs)}}class RollbackObjectsExecutor{constructor(){this.instructionType="rollbackObjects"}async execute(instruction,scope){const variable=scope.get(instruction.inputVar);if(variable instanceof MxObject)await rollback([variable]);else{if(!Array.isArray(variable))throw void 0===variable?new NanoflowError(`Cannot rollback $${instruction.inputVar} as it is empty`):new AssertionError;await rollback(variable)}}}async function rollback(mxobjs){return new Promise((resolve,reject)=>mx.data.rollback({mxobjs:mxobjs,callback:resolve,error:reject}))}class SynchronizeExecutor{constructor(){this.instructionType="synchronize"}async execute(_instruction,_scope){await methodToPromise(mx.data,"synchronizeOffline",{})}}class ReturnExecutor{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="return"}async execute(instruction,scope){return{result:this.evaluateExp(instruction.result,scope,instruction.resultKind)}}}class SetVariableExecutor{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="setVariable"}async execute(instruction,scope){scope.set(instruction.outputVar,this.evaluateExp(instruction.value,scope,instruction.outputKind))}}class SwitchExecutor{constructor(exprEvaluator){this.exprEvaluator=exprEvaluator,this.instructionType="switch"}async execute(instruction,scope){const value=this.exprEvaluator(instruction.condition,scope,"primitive"),valueString=void 0!==value?value.toString():"";if(!(valueString in instruction.targets))throw new AssertionError;return{goto:instruction.targets[valueString]}}}class TryCatchExecutor{constructor(executeInstructions){this.executeInstructions=executeInstructions,this.instructionType="tryCatch"}async execute(instruction,scope){try{return void await this.executeInstructions(instruction.body,scope)}catch(e){return e instanceof Error?scope.set(LATEST_ERROR,e.message):null!=e?scope.set(LATEST_ERROR,e.toString()):scope.set(LATEST_ERROR,void 0),{goto:instruction.catchTarget}}}}class CloseFormExecutor{constructor(){this.instructionType="closeForm"}async execute(_instruction,scope){scope.currentForm.close(()=>{},e=>mx.onError(e))}}class OpenFormExecutor{constructor(){this.instructionType="openForm"}async execute(instruction,scope){const param=instruction.inputVar?scope.get(instruction.inputVar):void 0;await mx.ui.openForm2(instruction.path,param?param.getGuid():void 0,instruction.title,scope.currentForm,instruction.params)}}class ShowMessageExecutor{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="showMessage"}async execute(instruction,scope){const expressionResult=this.evaluateExp(instruction.message,scope,"primitive"),message=void 0===expressionResult?"":expressionResult;mx.ui.showMessage(instruction.messageType,message,instruction.blocking)}}class ShowValidationExecutor{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="showValidation"}async execute(instruction,scope){const variable=scope.get(instruction.inputVar);if(void 0===variable)throw new NanoflowError(`Cannot refresh $${instruction.inputVar} as it is empty`);if(!(variable instanceof MxObject))throw new AssertionError;const expressionResult=this.evaluateExp(instruction.text,scope,"primitive"),validationText=void 0===expressionResult?"":expressionResult,existingValidations=function(scope,guid){const validationMap=scope[symbol]||(scope[symbol]={});return validationMap[guid]||(validationMap[guid]={})}(scope,variable.getGuid());existingValidations[instruction.member]=validationText;const ov=new ObjectValidation(variable.getGuid(),existingValidations);mx.data.sendValidationUpdates([ov])}}const symbol=Symbol("validations");class WriteLogExecutor{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="writeLog"}async execute(instruction,scope){const message=this.evaluateExp(instruction.message,scope,"primitive");mx.logger.log(instruction.level,message)}}class MicroflowCallExecutor{constructor(evaluateFlowExpression){this.evaluateFlowExpression=evaluateFlowExpression,this.instructionType="microflowCall"}async execute({flow:flow,parameters:parameters,outputVar:outputVar},scope){const microflowParameters=this.toMicroflowParameters(parameters,scope),result=mx.isOffline()?await mx.offlineData.executeMicroflow(flow,microflowParameters):await mx.onlineData.executeMicroflow(flow,microflowParameters,scope.currentForm);void 0!==outputVar&&scope.set(outputVar,result)}toMicroflowParameters(parameters,scope){const microflowParameters={};return parameters.forEach(({name:name,value:value,kind:kind})=>{const expressionResult=this.evaluateFlowExpression(value,scope,kind);if("object"===kind&&expressionResult instanceof MxObject)microflowParameters[name]={guid:expressionResult.getGuid()};else if("list"===kind&&Array.isArray(expressionResult))microflowParameters[name]={guids:expressionResult.map(mxobj=>mxobj.getGuid())};else if("primitive"===kind){const runtimeValue=expressionVariableToRuntimeValue(expressionResult);null!==runtimeValue&&(microflowParameters[name]={value:runtimeValue})}}),microflowParameters}}const nanoflowEngine=new class{constructor(lazyExecutors,getNanoflowFromRegistry){this.getNanoflowFromRegistry=getNanoflowFromRegistry,this.executors=lazyExecutors(this)}async execute(nanoflowId,args,currentForm){await wait(0);const scope=new FlowScope(currentForm);try{const instructions=this.getNanoflowFromRegistry(nanoflowId).instructions;return args.forEach(({name:name,value:value})=>scope.set(name,value)),await this.executeInstructions(instructions,scope)}finally{scope.destroy()}}async executeInstructions(instructions,scope){let index=0;for(;index<instructions.length;){const instruction=instructions[index],executor=this.executors.find(e=>e.instructionType===instruction.type);if(void 0===executor)throw new AssertionError;const executorResult=await executor.execute(instruction,scope);if(void 0!==(value=executorResult)&&"object"==typeof value&&"goto"in value){if(-1===(index=instructions.findIndex(i=>i.label===executorResult.goto)))throw new AssertionError}else{if(isReturn(executorResult))return executorResult.result;index++}}var value;throw new AssertionError}}(engine=>{const executeInstructions=(instructions,scope)=>engine.executeInstructions(instructions,scope),executeNanoflow=(nanoflowId,args,form)=>engine.execute(nanoflowId,args,form);return[new JumpExecutor,new SwitchExecutor(evaluateFlowExpression),new LoopExecutor(executeInstructions),new TryCatchExecutor(executeInstructions),new ReturnExecutor(evaluateFlowExpression),new CreateObjectExecutor,new ChangeObjectExecutor(evaluateFlowExpression),new CommitObjectsExecutor,new RollbackObjectsExecutor,new SetVariableExecutor(evaluateFlowExpression),new OpenFormExecutor,new CloseFormExecutor,new ShowValidationExecutor(evaluateFlowExpression),new DatabaseRetrieveExecutor(evaluateFlowExpression),new AssociationRetrieveExecutor,new WriteLogExecutor(evaluateFlowExpression),new JavaScriptActionExecutor(evaluateFlowExpression,executeNanoflow),new SynchronizeExecutor,new FilterListExecutor(evaluateFlowExpression),new AggregateExecutor,new ShowMessageExecutor(evaluateFlowExpression),new NanoflowCallExecutor(evaluateFlowExpression,executeNanoflow),new MicroflowCallExecutor(evaluateFlowExpression)]},getNanoflow);export{ObjectValidation as O,never as a,methodToPromise as m,nanoflowEngine as n,wait as w};
