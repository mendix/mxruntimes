import{g as deepEqual}from"./5dda5eb7.js";import{k as isString,b as AssertionError,l as isArrayOf}from"./ddd19e5a.js";import{a as Big}from"./3019ed1f.js";import{m as startOfMinute,n as endOfMinute,o as startOfHour,p as endOfHour,q as startOfDay,r as endOfDay,s as startOfWeek,t as endOfWeek,u as startOfMonth,v as endOfMonth,w as startOfYear,x as endOfYear}from"./d9069e30.js";import{a as MxObject,m as clientToAttributeValue}from"./3c905f8d.js";class Evaluator{constructor(expressionFunctions,expressionTokens){this.expressionFunctions=expressionFunctions,this.expressionTokens=expressionTokens}evaluate(expr,resolver){switch(expr.type){case"function":if(!this.expressionFunctions[expr.name])throw new Error(`Function ${expr.name} is not known`);const values=expr.parameters.map(exp=>this.evaluate(exp,resolver));return this.expressionFunctions[expr.name].apply(null,values);case"literal":return"number"==typeof expr.value?new Big(expr.value):null===expr.value?void 0:expr.value;case"variable":return void 0!==expr.path?resolver.resolve(expr.variable,expr.path):resolver.resolve(expr.variable);case"conditional":return this.evaluate(expr.condition,resolver)?this.evaluate(expr.then,resolver):this.evaluate(expr.else,resolver);case"token":if(!this.expressionTokens[expr.name])throw new Error(`Token ${expr.name} is not known`);return this.expressionTokens[expr.name]()}}}const expressionFunctions={not:arg=>!arg,"=":(arg1,arg2)=>arg1 instanceof Big&&arg2 instanceof Big?arg1.eq(arg2):arg1 instanceof Date&&arg2 instanceof Date?arg1.getTime()===arg2.getTime():"string"==typeof arg1||"string"==typeof arg2?(arg1||"")===(arg2||""):arg1 instanceof Array&&arg2 instanceof Array?arg1.length===arg2.length&&arg1.every(elem=>arg2.indexOf(elem)>-1):arg1 instanceof Array&&void 0===arg2?0===arg1.length:void 0===arg1&&arg2 instanceof Array?0===arg2.length:arg1===arg2,"!=":(arg1,arg2)=>!expressionFunctions["="](arg1,arg2),">"(arg1,arg2){if(arg1 instanceof Big&&arg2 instanceof Big)return arg1.gt(arg2);if(arg1 instanceof Date&&arg2 instanceof Date)return arg1.getTime()>arg2.getTime();if(void 0===arg1||void 0===arg2)throw new Error(operationErrorText(">",arg1,arg2));return arg1>arg2},">=":(arg1,arg2)=>expressionFunctions["="](arg1,arg2)||expressionFunctions[">"](arg1,arg2),"<"(arg1,arg2){if(arg1 instanceof Big&&arg2 instanceof Big)return arg1.lt(arg2);if(arg1 instanceof Date&&arg2 instanceof Date)return arg1.getTime()<arg2.getTime();if(void 0===arg1||void 0===arg2)throw new Error(operationErrorText("<",arg1,arg2));return arg1<arg2},"<=":(arg1,arg2)=>expressionFunctions["="](arg1,arg2)||expressionFunctions["<"](arg1,arg2),"+"(arg1,arg2){if(arg1 instanceof Big&&arg2 instanceof Big)return arg1.plus(arg2);if("string"==typeof arg1)return arg1+(void 0!==arg2?arg2.toString():"");if("string"==typeof arg2)return(void 0!==arg1?arg1.toString():"")+arg2;throw new Error(operationErrorText("+",arg1,arg2))},"-"(arg1,arg2){if(1===arguments.length&&void 0!==arg1)return arg1.times(-1);if(void 0!==arg1&&void 0!==arg2)return arg1.minus(arg2);throw new Error(operationErrorText("-",arg1,arg2))},"*"(arg1,arg2){if(void 0!==arg1&&void 0!==arg2)return arg1.times(arg2);throw new Error(operationErrorText("*",arg1,arg2))},div(arg1,arg2){if(void 0!==arg1&&void 0!==arg2)return arg1.div(arg2);throw new Error(operationErrorText("div",arg1,arg2))},mod(arg1,arg2){if(void 0!==arg1&&void 0!==arg2)return arg1.mod(arg2);throw new Error(operationErrorText("mod",arg1,arg2))},":":(arg1,arg2)=>expressionFunctions.div(arg1,arg2),max(...args){if(args[0]instanceof Big)return args.reduce((n1,n2)=>n1.gt(n2)?n1:n2);if(args[0]instanceof Date)return args.reduce((d1,d2)=>d1.getTime()>d2.getTime()?d1:d2);throw new Error(operationErrorText("max",...args))},min(...args){if(args[0]instanceof Big)return args.reduce((n1,n2)=>n1.lt(n2)?n1:n2);if(args[0]instanceof Date)return args.reduce((d1,d2)=>d1.getTime()<d2.getTime()?d1:d2);throw new Error(operationErrorText("min",...args))},round(arg,dp){if(arg instanceof Big)return arg.round(void 0===dp?0:Number(dp));throw new Error(operationErrorText("round",arg))},random:()=>new Big(Math.random()),floor(arg){if(arg instanceof Big){const fractional=arg.mod(1);return fractional.eq(0)?arg.eq(-0)?arg.abs():arg:arg.minus(fractional).minus(arg.lt(0)?1:0)}throw new Error(operationErrorText("floor",arg))},ceil(arg){if(arg instanceof Big){const result=expressionFunctions.floor(arg.times(-1));return result.eq(0)?result:result.times(-1)}throw new Error(operationErrorText("ceil",arg))},pow(arg,exponent){if(arg instanceof Big&&exponent instanceof Big)return arg.pow(Number(exponent));throw new Error(operationErrorText("pow",arg))},abs(arg){if(arg instanceof Big)return arg.abs();throw new Error(operationErrorText("abs",arg))},parseInteger(arg,defaultValue){if("string"==typeof arg){if(/^-?\d+$/.test(arg)){const result=Big(arg);return result.eq(-0)?result.abs():result}if(void 0===defaultValue)throw new Error(`Not parsable to Integer: ${arg}`);return defaultValue}throw new Error(operationErrorText("parseInteger",arg))},parseDecimal(arg,defaultValue){if("string"==typeof arg){const parsed=mx.parser.parseValue(arg,"Decimal");if(null===parsed&&void 0===defaultValue)throw new Error(`Not parsable to Decimal: ${arg}`);return null===parsed?defaultValue:parsed}throw new Error(operationErrorText("parseDecimal",arg))},formatDecimal(arg){if(arg instanceof Big)return mx.parser.formatValue(Number(arg),"Decimal");throw new Error(operationErrorText("formatDecimal",arg))},isNew:arg1=>void 0!==arg1&&mx.data.isNew(arg1),isSynced(arg1){if(void 0!==arg1)return!mx.data.isDirty(arg1);throw new Error(operationErrorText("isSynced",arg1))},toString(arg1){if(arg1 instanceof Big)return arg1.toString();if(void 0===arg1)return"";if(arg1 instanceof Date)throw new Error(operationErrorText("toString",arg1));return String(arg1)},toUpperCase:arg1=>asString(arg1).toUpperCase(),toLowerCase:arg1=>asString(arg1).toLowerCase(),trim:arg1=>asString(arg1).trim(),contains:(arg1,arg2)=>asString(arg1).indexOf(asString(arg2))>-1,startsWith:(arg1,arg2)=>(arg1=asString(arg1),arg2=asString(arg2),arg1.substr(0,arg2.length)===arg2),endsWith:(arg1,arg2)=>(arg1=asString(arg1),arg2=asString(arg2),arg1.substr(arg1.length-arg2.length)===arg2),substring(arg1,arg2,arg3){if(arg1=asString(arg1),arg3=arg3,void 0!==(arg2=arg2)&&arg2.gte(0)){if(2===arguments.length)return arg1.substr(Number(arg2));if(void 0!==arg3&&arg3.gte(0))return arg1.substr(Number(arg2),Number(arg3))}throw new Error(operationErrorText("substring",arg1,arg2,arg3))},find(arg1,arg2,arg3){if(arg1=asString(arg1),arg2=asString(arg2),2===arguments.length)return new Big(arg1.indexOf(arg2));if(void 0!==arg3)return new Big(arg1.indexOf(arg2,Number(arg3)));throw new Error(operationErrorText("find",arg1,arg2,arg3))},findLast(arg1,arg2,arg3){if(arg1=asString(arg1),arg2=asString(arg2),2===arguments.length)return new Big(arg1.lastIndexOf(arg2));if(void 0!==arg3)return new Big(arg1.lastIndexOf(arg2,Number(arg3)));throw new Error(operationErrorText("findLast",arg1,arg2,arg3))},length:arg1=>new Big(asString(arg1).length),urlEncode:arg1=>encodeURIComponent(asString(arg1)).replace("%20","+"),urlDecode:arg1=>decodeURIComponent(asString(arg1).replace("+","%20")),isMatch(arg1,arg2){if(void 0!==arg2)return new RegExp(`^(${arg2})$`).test(asString(arg1));throw new Error(operationErrorText("isMatch",arg1,arg2))},replaceFirst(arg1,arg2,arg3){if(void 0!==arg2&&void 0!==arg3){const escapedForReplaceValue=arg3.replace(/\$/g,"$$$$");return asString(arg1).replace(new RegExp(arg2),escapedForReplaceValue)}throw new Error(operationErrorText("replaceFirst",arg1,arg2))},replaceAll(arg1,arg2,arg3){if(void 0!==arg2&&void 0!==arg3){const escapedForReplaceValue=arg3.replace(/\$/g,"$$$$");return asString(arg1).replace(new RegExp(arg2,"g"),escapedForReplaceValue)}throw new Error(operationErrorText("replaceAll",arg1,arg2))},_newList:()=>[],_toList:arg1=>asList(arg1,operationErrorText("_toList",arg1)),_addToList(arg1,arg2){const arr1=asList(arg1,operationErrorText("_addToList",arg1,arg2)),arr2=asList(arg2,operationErrorText("_addToList",arg1,arg2));return arr1.concat(arr2.filter(guid=>!arr1.includes(guid)))},_removeFromList(arg1,arg2){const arr1=asList(arg1,operationErrorText("_removeFromList",arg1,arg2)),arr2=asList(arg2,operationErrorText("_removeFromList",arg1,arg2));return arr1.filter(guid=>!arr2.includes(guid))},_intersectLists(arg1,arg2){const arr1=asList(arg1,operationErrorText("_intersectLists",arg1,arg2)),arr2=asList(arg2,operationErrorText("_intersectLists",arg1,arg2));return arr1.filter(guid=>arr2.includes(guid))},_listContains(arg1,arg2){const arr1=asList(arg1,operationErrorText("_listContains",arg1,arg2)),arr2=asList(arg2,operationErrorText("_listContains",arg1,arg2));return arr2.length>0&&arr2.every(guid=>arr1.includes(guid))},_head(arg1){if(arg1 instanceof Array)return arg1.length>0?arg1[0]:void 0;if(void 0!==arg1)throw new Error(operationErrorText("_head",arg1))},_hasSomeRole:(...args)=>mx.session.hasSomeRole(args)};function operationErrorText(operator,...args){return`Operator ${operator} not supported in expression ${operator}(${args.join(", ")})`}function asString(arg){return void 0===arg?"":arg}function asList(arg,errorText){if(arg instanceof Array)return arg;if(isString(arg))return arg.length>0?[arg]:[];if(void 0===arg)return[];throw new Error(errorText)}const funcMap={beginOfCurrentMinute:startOfMinute,endOfCurrentMinute:endOfMinute,beginOfCurrentHour:startOfHour,endOfCurrentHour:endOfHour,beginOfCurrentDay:startOfDay,endOfCurrentDay:endOfDay,beginOfCurrentWeek:startOfWeek,endOfCurrentWeek:endOfWeek,beginOfCurrentMonth:startOfMonth,endOfCurrentMonth:endOfMonth,beginOfCurrentYear:startOfYear,endOfCurrentYear:endOfYear};function createExpressionTokens(getNow){const tokensCollection={currentUser:()=>mx.session.getUserId(),currentDateTime:getNow};return Object.keys(funcMap).forEach(exposedName=>{const func=funcMap[exposedName];tokensCollection[exposedName]=(()=>func(getNow(),{weekStartsOn:mx.session.getConfig("locale.firstDayOfWeek")})),tokensCollection[exposedName+"UTC"]=(()=>(function(date){const result=new Date(date.getTime());return result.setMinutes(result.getMinutes()-result.getTimezoneOffset()),result})(func(function(date){const result=new Date(date.getTime());return result.setMinutes(result.getMinutes()+result.getTimezoneOffset()),result}(getNow()))))}),tokensCollection}class AccessDeniedError extends Error{constructor(variableName,entityName,attributeName){super(`Unable to get a member from variable $${variableName}, because you do not have sufficient permissions to "${entityName}.${attributeName}".`),this.variableName=variableName,this.entityName=entityName,this.attributeName=attributeName,Object.setPrototypeOf(this,AccessDeniedError.prototype)}}class EmptyVariableAccessError extends Error{constructor(variableName){super(`Unable to get a member from an empty variable $${variableName}.`),this.variableName=variableName,Object.setPrototypeOf(this,EmptyVariableAccessError.prototype)}}class Resolver{constructor(variables){this.variables=variables,this.dependencies=[]}resolve(variable,path){return void 0!==path?this.resolveAttribute(variable,path):this.resolveVariable(variable)}getDependencies(){return this.dependencies.slice()}resolveVariable(name){if(!(name in this.variables))throw new AssertionError;const value=this.variables[name]();if(value instanceof MxObject)return this.addDependency({guid:value.getGuid()}),value.getGuid();if(isArrayOf(MxObject,value)){const guids=value.map(obj=>obj.getGuid());return guids.forEach(guid=>this.addDependency({guid:guid})),guids}return value}resolveAttribute(variable,attribute){if(!(variable in this.variables))throw new AssertionError;const obj=this.variables[variable]();if(void 0===obj)throw new EmptyVariableAccessError(variable);if(!(obj instanceof MxObject))throw new AssertionError;if(!obj.has(attribute))throw new AccessDeniedError(variable,obj.getEntity(),attribute);return this.addDependency({guid:obj.getGuid()}),this.addDependency({guid:obj.getGuid(),attr:attribute}),clientToAttributeValue(obj.get(attribute),obj.getAttributeType(attribute))}addDependency(dependency){this.dependencies.find(dep=>deepEqual(dep,dependency))||this.dependencies.push(dependency)}}export{Evaluator as a,expressionFunctions as b,createExpressionTokens as c,Resolver as d,EmptyVariableAccessError as e,AccessDeniedError as f};
