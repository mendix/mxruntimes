import{A as AssertionError,b as crash,d as escapeXml}from"./546dec4f.js";import{B as Big}from"./2bc24ff8.js";import{M as MxObject,e as clientToAttributeValue,h as anyToExpressionVariable,i as attributeToClientValue}from"./37fca272.js";import{s as subscribe}from"./38d79760.js";import{E as Evaluator,e as expressionFunctions,c as createExpressionTokens,R as Resolver}from"./92c47dca.js";async function never(){return new Promise(()=>{})}async function wait(timeout=0){return new Promise(resolve=>{setTimeout(()=>{resolve()},timeout)})}async function methodToPromise(subject,functionName,...args){return new Promise((resolve,reject)=>subject[functionName](...args,resolve,reject))}const LATEST_ERROR="latestError";class FlowScope{constructor(currentForm,executeNanoflow){this.currentForm=currentForm,this.executeNanoflow=executeNanoflow,this.map={},this.subscriptions=[],this.map[LATEST_ERROR]=void 0}set(name,value){this.map[name]=value,value instanceof MxObject?this.subscriptions.push(subscribe({guid:value.getGuid()})):Array.isArray(value)&&this.subscriptions.push(...value.map(obj=>subscribe({guid:obj.getGuid()})))}get(name){if(!(name in this.map))throw new AssertionError;const value=this.map[name];return value instanceof MxObject&&value.isUnavailable()?void 0:Array.isArray(value)?value.filter(v=>!v.isUnavailable()):value}all(){return Object.keys(this.map)}mapGuidsToObjects(guids){const guidToObj={};return this.all().map(vn=>this.get(vn)).map(value=>value instanceof MxObject?[value]:Array.isArray(value)?value:[]).reduce((a,b)=>a.concat(b),[]).forEach(mxobj=>{guidToObj[mxobj.getGuid()]=mxobj}),guids.filter(guid=>guid in guidToObj).map(guid=>guidToObj[guid])}destroy(){this.subscriptions.forEach(s=>s.unsubscribe()),this.subscriptions.splice(0)}}class NanoflowEngine{constructor(executors){this.executors=executors}async execute(nanoflow,parameters,currentForm){await wait(0);const scope=new FlowScope(currentForm,nf=>this.executeWithScope(nf,scope));try{return parameters.forEach(({name:name,value:value})=>scope.set(name,value)),await this.executeWithScope(nanoflow,scope)}finally{scope.destroy()}}async executeWithScope(nanoflow,scope){let index=0;for(;index<nanoflow.length;){const instruction=nanoflow[index],executor=this.executors.find(e=>e.instructionType===instruction.type);if(void 0===executor)throw new AssertionError;const executorResult=await executor.execute(instruction,scope);if(void 0!==(value=executorResult)&&"object"==typeof value&&"goto"in value){if(-1===(index=nanoflow.findIndex(i=>i.label===executorResult.goto)))throw new AssertionError}else{if(isReturn(executorResult))return executorResult.result;index++}}var value;throw new AssertionError}}function isReturn(value){return void 0!==value&&"object"==typeof value&&"result"in value}class ObjectValidation{constructor(guid,fields){this._guid=guid,this._fields=fields}getGuid(){return this._guid}getAttributes(){return Object.keys(this._fields).map(name=>({name:name,reason:this._fields[name]}))}getFields(){return this.getAttributes()}static describe(validations){const list=[];for(let i=0;void 0!==validations[i];i++){const fields=validations[i].getFields();for(let x=0;void 0!==fields[x];x++)list.push(fields[x].reason)}return list.join("\n")}addAttribute(attr,message){return!(attr in this._fields)&&(this._fields[attr]=message,!0)}addField(...args){return this.addAttribute(...args)}removeAttribute(attr){return attr in this._fields&&(delete this._fields[attr],!0)}removeField(...args){return this.removeAttribute(...args)}getErrorReason(attr){return this._fields[attr]}getReasonByAttribute(...args){return this.getErrorReason(...args)}clone(){return new ObjectValidation(this._guid,Object.assign({},this._fields))}toString(){return Object.keys(this._fields).map(attr=>`${attr} ${this._fields[attr]}`).join("; ")}}ObjectValidation.fromResponse=function(datavalidation){return datavalidation.map(({guid:guid,errorFields:errorFields})=>{const fieldMap={};return errorFields.forEach(({name:name,message:message})=>{fieldMap[name]=message}),new ObjectValidation(guid,fieldMap)})};const evaluator=new Evaluator(expressionFunctions,createExpressionTokens(()=>new Date)),evaluateFlowExpression=(expr,scope,resultKind)=>{const allValues={};scope.all().forEach(name=>allValues[name]=()=>scope.get(name));const exprResult=evaluator.evaluate(expr,new Resolver(allValues));switch(resultKind){case"primitive":return exprResult;case"list":return Array.isArray(exprResult)?scope.mapGuidsToObjects(exprResult):void 0===exprResult?[]:crash();case"object":return"string"==typeof exprResult?scope.mapGuidsToObjects([exprResult])[0]:void 0===exprResult?void 0:crash()}};var AggregateFunction;!function(AggregateFunction){AggregateFunction.Sum="Sum",AggregateFunction.Average="Average",AggregateFunction.Count="Count",AggregateFunction.Minimum="Minimum",AggregateFunction.Maximum="Maximum"}(AggregateFunction||(AggregateFunction={}));function sum(values){return values.reduce((sum,curValue)=>sum.plus(curValue),new Big(0))}class NanoflowError extends Error{constructor(message){super(message),Object.setPrototypeOf(this,NanoflowError.prototype)}}async function commit(mxobjs){return new Promise((resolve,reject)=>mx.data.commit({mxobjs:mxobjs,callback:resolve,error:reject}))}const expressionTokens=createExpressionTokens(()=>new Date);function toQueryFilterValue(source,attribute){if(null!=source){if("string"==typeof source||"boolean"==typeof source||source instanceof Date||source instanceof Big)return source;if("number"==typeof source)return Big(source);if(source instanceof MxObject){if(void 0!==attribute){return clientToAttributeValue(source.get(attribute),source.getAttributeType(attribute))}return source.getGuid()}throw new AssertionError(`Cannot use value '${source}' in query filter`)}}function toXpathConstraint(filter){switch(filter.type){case"attribute":return filter.attribute;case"value":const value=filter.value;if(void 0===value)return"empty";if("string"==typeof value)return`'${escapeXml(value)}'`;if("boolean"==typeof value)return value?"true()":"false()";if(value instanceof Big)return value.toString();if(value instanceof Date)return value.getDate().toString();throw new AssertionError;case"function":return/^(\W+|and|or)$/.test(filter.name)?"("+filter.parameters.map(toXpathConstraint).join(` ${filter.name} `)+")":`${filter.name}(`+filter.parameters.map(toXpathConstraint).join(", ")+")"}}async function rollback(mxobjs){return new Promise((resolve,reject)=>mx.data.rollback({mxobjs:mxobjs,callback:resolve,error:reject}))}const symbol=Symbol("validations");const executors=[new class{constructor(){this.instructionType="jump"}async execute(instruction,_scope){return{goto:instruction.target}}},new class{constructor(exprEvaluator){this.exprEvaluator=exprEvaluator,this.instructionType="switch"}async execute(instruction,scope){const value=this.exprEvaluator(instruction.condition,scope,"primitive"),valueString=void 0!==value?value.toString():"";if(!(valueString in instruction.targets))throw new AssertionError;return{goto:instruction.targets[valueString]}}}(evaluateFlowExpression),new class{constructor(){this.instructionType="loop"}async execute(instruction,scope){const list=scope.get(instruction.listVar);if(!Array.isArray(list))throw new AssertionError;for(const obj of list)if(scope.set(instruction.iteratorVar,obj),await scope.executeNanoflow(instruction.body))break}},new class{constructor(){this.instructionType="tryCatch"}async execute(instruction,scope){try{return void await scope.executeNanoflow(instruction.body)}catch(e){return e instanceof Error?scope.set(LATEST_ERROR,e.message):null!=e?scope.set(LATEST_ERROR,e.toString()):scope.set(LATEST_ERROR,void 0),{goto:instruction.catchTarget}}}},new class{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="return"}async execute(instruction,scope){return{result:this.evaluateExp(instruction.result,scope,instruction.resultKind)}}}(evaluateFlowExpression),new class{constructor(){this.instructionType="createObject"}async execute(instruction,scope){const obj=await new Promise((resolve,reject)=>mx.data.create({entity:instruction.objectType,callback:resolve,error:reject}));scope.set(instruction.outputVar,obj)}},new class{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="changeObject"}async execute(instruction,scope){const obj=scope.get(instruction.inputVar);if(void 0===obj)throw new NanoflowError(`Cannot change $${instruction.inputVar} as it is empty`);if(!(obj instanceof MxObject))throw new AssertionError;const exprValue=this.evaluateExp(instruction.value,scope,"primitive");let clientValue=attributeToClientValue(exprValue);clientValue instanceof Big&&(clientValue=clientValue.round(8)),obj.set(instruction.member,clientValue)}}(evaluateFlowExpression),new class{constructor(){this.instructionType="commitObjects"}async execute(instruction,scope){const variable=scope.get(instruction.inputVar);if(variable instanceof MxObject)await commit([variable]);else{if(!Array.isArray(variable))throw void 0===variable?new NanoflowError(`Cannot commit $${instruction.inputVar} as it is empty`):new AssertionError;await commit(variable)}}},new class{constructor(){this.instructionType="rollbackObjects"}async execute(instruction,scope){const variable=scope.get(instruction.inputVar);if(variable instanceof MxObject)await rollback([variable]);else{if(!Array.isArray(variable))throw void 0===variable?new NanoflowError(`Cannot rollback $${instruction.inputVar} as it is empty`):new AssertionError;await rollback(variable)}}},new class{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="setVariable"}async execute(instruction,scope){scope.set(instruction.outputVar,this.evaluateExp(instruction.value,scope,instruction.outputKind))}}(evaluateFlowExpression),new class{constructor(){this.instructionType="openForm"}async execute(instruction,scope){const param=instruction.inputVar?scope.get(instruction.inputVar):void 0;await mx.ui.openForm2(instruction.path,param?param.getGuid():void 0,instruction.title,scope.currentForm,instruction.params)}},new class{constructor(){this.instructionType="closeForm"}async execute(_instruction,scope){scope.currentForm.close(()=>{},e=>mx.onError(e))}},new class{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="showValidation"}async execute(instruction,scope){const variable=scope.get(instruction.inputVar);if(void 0===variable)throw new NanoflowError(`Cannot refresh $${instruction.inputVar} as it is empty`);if(!(variable instanceof MxObject))throw new AssertionError;const expressionResult=this.evaluateExp(instruction.text,scope,"primitive"),validationText=void 0===expressionResult?"":expressionResult,existingValidations=function(scope,guid){const validationMap=scope[symbol]||(scope[symbol]={});return validationMap[guid]||(validationMap[guid]={})}(scope,variable.getGuid());existingValidations[instruction.member]=validationText;const ov=new ObjectValidation(variable.getGuid(),existingValidations);mx.data.sendValidationUpdates([ov])}}(evaluateFlowExpression),new class{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="databaseRetrieve"}async execute(instruction,scope){const{entity:entity,constraints:constraints,limitExpr:limitExpr,offsetExpr:offsetExpr,takeFirst:takeFirst,sort:sort,outputVar:outputVar}=instruction,limit=limitExpr?this.evaluateExp(limitExpr,scope,"primitive"):void 0,offset=offsetExpr?this.evaluateExp(offsetExpr,scope,"primitive"):void 0,filter=constraints?function toQueryFilter(constraint,scope){switch(constraint.type){case"attribute":return constraint;case"function":return{type:"function",name:constraint.name,parameters:constraint.parameters.map(p=>toQueryFilter(p,scope))};case"literal":return{type:"value",value:toQueryFilterValue(constraint.value)};case"token":return{type:"value",value:expressionTokens[constraint.name]()};case"variable":return{type:"value",value:toQueryFilterValue(scope.get(constraint.name),constraint.attribute)}}}(constraints,scope):void 0,options=Object.assign({},offset?{offset:Number(offset)}:{},limit?{amount:Number(limit)}:{},sort?{sort:sort}:{}),{mxobjs:mxobjs}=mx.isOffline()?await mx.offlineData.getByQuery(entity,filter,options):await mx.onlineData.getByXPath(`//${entity}`+(filter?`[${toXpathConstraint(filter)}]`:""),options);scope.set(outputVar,takeFirst?mxobjs[0]:mxobjs)}}(evaluateFlowExpression),new class{constructor(){this.instructionType="associationRetrieve"}async execute(instruction,scope){const{inputVar:inputVar,association:association,entity:entity,retrieveSingleObject:retrieveSingleObject,direction:direction,outputVar:outputVar}=instruction,obj=scope.get(inputVar);if(void 0===obj)return void scope.set(outputVar,retrieveSingleObject?void 0:[]);if(!(obj instanceof MxObject))throw new AssertionError;const mxobjs=await async function(mxobj,path,entity,direction){return new Promise((resolve,reject)=>{mx.data.get({guid:mxobj.getGuid(),path:path,entity:entity,direction:direction,callback:resolve,error:reject})})}(obj,association,entity,direction);scope.set(outputVar,retrieveSingleObject?mxobjs[0]:mxobjs)}},new class{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="writeLog"}async execute(instruction,scope){const message=this.evaluateExp(instruction.message,scope,"primitive");mx.logger.log(instruction.level,message)}}(evaluateFlowExpression),new class{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="javaScriptActionCall"}async execute(instruction,scope){const resolvedParameters=instruction.parameters.map(({kind:kind,value:value})=>this.evaluateExp(value,scope,kind)),action=await mx.ui.getJavaScriptAction(instruction.name),result=await action(...resolvedParameters);instruction.outputVar&&scope.set(instruction.outputVar,anyToExpressionVariable(result))}}(evaluateFlowExpression),new class{constructor(){this.instructionType="synchronize"}async execute(_instruction,_scope){await methodToPromise(mx.data,"synchronizeOffline",{})}},new class{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="filterList"}async execute(instruction,scope){const input=scope.get(instruction.inputVar),expected=this.evaluateExp(instruction.expectedValue,scope,"primitive"),result=Array.isArray(input)?input.filter(function(obj){const value=obj.get(instruction.attribute),type=obj.getAttributeType(instruction.attribute);return expressionFunctions["="](clientToAttributeValue(value,type),expected)}):[];scope.set(instruction.outputVar,instruction.retrieveSingleObject?result.length>0?result[0]:void 0:result)}}(evaluateFlowExpression),new class{constructor(){this.instructionType="aggregate"}async execute(instruction,scope){const inputList=scope.get(instruction.inputVar);Array.isArray(inputList)&&(instruction.operation===AggregateFunction.Count?scope.set(instruction.outputVar,new Big(inputList.length)):scope.set(instruction.outputVar,function(inputList,operation,member){const inputValues=inputList.map(obj=>obj.get(member)).filter(val=>val instanceof Big);switch(operation){case AggregateFunction.Minimum:return 0===inputValues.length?void 0:inputValues.reduce((curMin,curVal)=>curVal.lt(curMin)?curVal:curMin,inputValues[0]);case AggregateFunction.Maximum:return 0===inputValues.length?void 0:inputValues.reduce((curMax,curVal)=>curVal.gt(curMax)?curVal:curMax,inputValues[0]);case AggregateFunction.Average:return 0===inputValues.length?void 0:sum(inputValues).div(inputValues.length);case AggregateFunction.Sum:return sum(inputValues)}}(inputList,instruction.operation,instruction.member)))}},new class{constructor(evaluateExp){this.evaluateExp=evaluateExp,this.instructionType="showMessage"}async execute(instruction,scope){const expressionResult=this.evaluateExp(instruction.message,scope,"primitive"),message=void 0===expressionResult?"":expressionResult;mx.ui.showMessage(instruction.messageType,message,instruction.blocking)}}(evaluateFlowExpression)];export{NanoflowEngine as N,ObjectValidation as O,executors as e,methodToPromise as m,never as n,wait as w};
