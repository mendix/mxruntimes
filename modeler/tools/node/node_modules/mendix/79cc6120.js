import{c as configure,d as computed,o as observable,e as createAtom,f as allowStateChangesInsideComputed,r as reaction,b as runInAction}from"./f0d16cff.js";import{A as AssertionError,s as subscribe}from"./ad1d08ab.js";import{f as fromLoadable}from"./0e7164f2.js";function ensure(arg){if(null==arg)throw new Error("Did not expect an argument to be undefined");return arg}function crash(){throw new AssertionError}function friendlyName(Component){return Component.displayName||Component.name||"<component>"}function isString(value){return"string"==typeof value}function isJson(obj){return null!=obj&&"object"==typeof obj&&obj.constructor==={}.constructor}function isArrayOf(type,value){return value instanceof Array&&value.every(v=>void 0===v||v instanceof type)}function splitAttributePath(attributePath){const parts=attributePath.split("/");return parts.length>1&&parts.shift(),{attribute:parts.pop(),entityPath:parts.length?parts.join("/"):void 0}}function unique(list){return Array.from(new Set(list))}function tuple(...args){return args}function mapValues(source,mapValue){const result={};return Object.keys(source).forEach(key=>result[key]=mapValue(source[key])),result}function uniqueBy(list,keySelector){const res=[],keys={};return list.forEach(item=>{const key=keySelector(item);Object.prototype.hasOwnProperty.call(keys,key)||(keys[key]=!0,res.push(item))}),res}function concat(arrays){return[].concat(...arrays)}function escapeXml(s){return s.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&apos;")}function containsKey(key,obj){return Object.prototype.hasOwnProperty.call(obj,key)}function subscriptionDependency(name,subscription){let handle;const atom=createAtom(name,()=>{handle=subscribe(Object.assign(Object.assign({tag:name},subscription),{callback:()=>atom.reportChanged()}))},()=>{ensure(handle).unsubscribe(),handle=void 0});return{reportObserved:()=>{atom.reportObserved()}}}function timerDependency(name,time){let handle;const atom=createAtom(name,()=>{handle=setInterval(()=>atom.reportChanged(),time)},()=>{clearInterval(ensure(handle)),handle=void 0});return{reportObserved:()=>{atom.reportObserved()}}}function loadableResource(name,factory,initialValue=loading()){const atom=createAtom(name,fetchResource);let value;function fetchResource(){const result=factory();result instanceof Promise?(value=initialValue,result.then(finalValue=>{value=finalValue,atom.reportChanged()},e=>mx.onError(e))):value=result}return computed(()=>(atom.reportObserved()||fetchResource(),value))}function loadableDependentResource(name,getParameter$,factory){const resourceBox=observable.box(computed(()=>loading()),{deep:!1});return using(()=>[reaction(getParameter$,param=>resourceBox.set(loadableResource(name,()=>factory(param))),{fireImmediately:!0})],()=>resourceBox.get().get())}function using(resourcesFactory,func$){let resourceDisposers;const atom=createAtom("Resources tracker",()=>{resourceDisposers=resourcesFactory()},()=>resourceDisposers.forEach(r=>r()));return computed(()=>{const result=func$();return atom.reportObserved(),result})}function valueMonitor(expression){let lastSeenValue,firstRun=!0;const atom=createAtom(`Inline reaction on ${expression}`,void 0,()=>firstRun=!0),computedValue=computed(expression);return{runIfChanged(effect){if(!atom.reportObserved())throw new AssertionError;const newValue=computedValue.get();(firstRun||lastSeenValue!==newValue)&&(firstRun=!1,lastSeenValue=newValue,runActionInComputed(()=>effect(newValue)))}}}function runActionInComputed(action){allowStateChangesInsideComputed(()=>runInAction(action))}configure({enforceActions:"always"});const LOADING={status:"loading"};function loading(){return LOADING}const UNAVAILABLE={status:"unavailable"};function unavailable(){return UNAVAILABLE}function available(value){return{status:"available",value:value}}function getOrElseL(value,def){return"available"===value.status?value.value:def}function getOrCrashL(value){return"available"===value.status?value.value:crash()}function liftL(action){return loadable=>mapL(loadable,action)}function mapL(loadable,action){return flatMapL(loadable,v=>available(action(v)))}function flatMapL(loadable,action){return"available"===loadable.status?action(loadable.value):loadable}function flattenArrayL(array){return array.reduce((acc,el)=>acc.concat("available"===el.status?[el.value]:[]),[])}function asDynamicValue(func$){return asReloadable(()=>fromLoadable(func$()),v=>({value:v.value}))}const DEBOUNCE_DELAY=100;let debounceEnabled=!0;function asReloadable(func$,rememberFunc){const value=observable.box(void 0,{deep:!1}),funcMonitor=valueMonitor(func$);let timeoutHandle,lastSeenValue={};return using(()=>[()=>runInAction(()=>value.set(void 0)),()=>window.clearTimeout(timeoutHandle)],()=>(funcMonitor.runIfChanged(newValue=>{switch(window.clearTimeout(timeoutHandle),newValue.status){case"loading":void 0===value.get()?value.set(newValue):debounceEnabled?timeoutHandle=window.setTimeout(()=>runInAction(()=>{value.set(Object.assign(Object.assign({},newValue),lastSeenValue))}),DEBOUNCE_DELAY):value.set(Object.assign(Object.assign({},newValue),lastSeenValue));break;case"unavailable":lastSeenValue={},value.set(newValue);break;case"available":lastSeenValue=rememberFunc(newValue),value.set(newValue)}}),ensure(value.get())))}export{asReloadable as A,loadableDependentResource as B,runActionInComputed as C,timerDependency as D,tuple as E,liftL as F,available as a,uniqueBy as b,concat as c,mapL as d,ensure as e,friendlyName as f,getOrElseL as g,crash as h,isJson as i,escapeXml as j,unavailable as k,loading as l,mapValues as m,flatMapL as n,using as o,flattenArrayL as p,loadableResource as q,isString as r,subscriptionDependency as s,isArrayOf as t,unique as u,containsKey as v,getOrCrashL as w,splitAttributePath as x,asDynamicValue as y,valueMonitor as z};
