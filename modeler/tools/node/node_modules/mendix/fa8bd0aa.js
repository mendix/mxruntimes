import{f as computed,c as configure,o as observable,d as createAtom,g as allowStateChangesInsideComputed,r as reaction,b as runInAction}from"./ef69c932.js";import{A as AssertionError}from"./53bf75a6.js";import{b as crash,e as ensure}from"./567083d6.js";import{s as subscribe}from"./84420dbd.js";import{f as fromLoadable}from"./573c00fc.js";const LOADING={status:"loading"};function loading(){return LOADING}const UNAVAILABLE={status:"unavailable"};function unavailable(){return UNAVAILABLE}function available(value){return{status:"available",value:value}}function getOrElseL(value,def){return"available"===value.status?value.value:def}function getOrCrashL(value){return"available"===value.status?value.value:crash()}function liftL(action){return loadable=>mapL(loadable,action)}function mapL(loadable,action){return flatMapL(loadable,v=>available(action(v)))}function flatMapL(loadable,action){return"available"===loadable.status?action(loadable.value):loadable}function flattenArrayL(array){return array.reduce((acc,el)=>acc.concat("available"===el.status?[el.value]:[]),[])}function asDynamicValue(func$){return asReloadable(()=>fromLoadable(func$()),v=>({value:v.value}))}function asReloadable(func$,rememberFunc){let lastSeenValue;return computed(()=>{const value=func$();switch(value.status){case"loading":return Object.assign({},value,lastSeenValue);case"unavailable":return lastSeenValue={},value;case"available":return lastSeenValue=rememberFunc(value),value}})}function subscriptionDependency(name,subscription){let handle;const atom=createAtom(name,()=>{handle=subscribe(Object.assign({tag:name},subscription,{callback:()=>atom.reportChanged()}))},()=>{ensure(handle).unsubscribe(),handle=void 0});return{reportObserved:()=>{atom.reportObserved()}}}function timerDependency(name,time){let handle;const atom=createAtom(name,()=>{handle=setInterval(()=>atom.reportChanged(),time)},()=>{clearInterval(ensure(handle)),handle=void 0});return{reportObserved:()=>{atom.reportObserved()}}}function loadableResource(name,factory,initialValue=loading()){const atom=createAtom(name,fetchResource);let value;function fetchResource(){const result=factory();result instanceof Promise?(value=initialValue,result.then(finalValue=>{value=finalValue,atom.reportChanged()},e=>mx.onError(e))):value=result}return computed(()=>(atom.reportObserved()||fetchResource(),value))}function loadableDependentResource(name,getParameter$,factory){const resourceBox=observable.box(computed(()=>loading()),{deep:!1});return using(()=>[reaction(getParameter$,param=>resourceBox.set(loadableResource(name,()=>factory(param))),{fireImmediately:!0})],()=>resourceBox.get().get())}function using(resourcesFactory,func$){let resourceDisposers;const atom=createAtom("Resources tracker",()=>{resourceDisposers=resourcesFactory()},()=>resourceDisposers.forEach(r=>r()));return computed(()=>{const result=func$();return atom.reportObserved(),result})}function valueMonitor(expression){let lastSeenValue,firstRun=!0;const atom=createAtom(`Inline reaction on ${expression}`,void 0,()=>firstRun=!0);return{runIfChanged(effect){if(!atom.reportObserved())throw new AssertionError;const newValue=expression();(firstRun||lastSeenValue!==newValue)&&(firstRun=!1,lastSeenValue=newValue,runActionInComputed(()=>effect(newValue)))}}}function runActionInComputed(action){allowStateChangesInsideComputed(()=>runInAction(action))}configure({enforceActions:"always"});export{available as a,using as b,flattenArrayL as c,loadableResource as d,getOrCrashL as e,flatMapL as f,getOrElseL as g,asDynamicValue as h,asReloadable as i,loadableDependentResource as j,liftL as k,loading as l,mapL as m,runActionInComputed as r,subscriptionDependency as s,timerDependency as t,unavailable as u,valueMonitor as v};
